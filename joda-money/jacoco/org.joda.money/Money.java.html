<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Money.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda-Money</a> &gt; <a href="index.source.html" class="el_package">org.joda.money</a> &gt; <span class="el_source">Money.java</span></div><h1>Money.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2009-present, Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.money;

import java.io.InvalidObjectException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Arrays;

import org.joda.convert.FromString;
import org.joda.convert.ToString;

/**
 * An amount of money with the standard decimal places defined by the currency.
 * &lt;p&gt;
 * This class represents a quantity of money, stored as a {@code BigDecimal} amount
 * in a single {@link CurrencyUnit currency}.
 * &lt;p&gt;
 * Every currency has a certain standard number of decimal places.
 * This is typically 2 (Euro, British Pound, US Dollar) but might be
 * 0 (Japanese Yen), 1 (Vietnamese Dong) or 3 (Bahrain Dinar).
 * The {@code Money} class is fixed to this number of decimal places.
 * &lt;p&gt;
 * For example, US dollars has a standard number of decimal places of 2.
 * The major units are dollars. The minor units are cents, 100 to the dollar.
 * This class does not allow calculations on fractions of a cent.
 * &lt;p&gt;
 * This class is immutable and thread-safe.
 */
<span class="fc" id="L45">public final class Money implements BigMoneyProvider, Comparable&lt;BigMoneyProvider&gt;, Serializable {</span>

    /**
     * The serialisation version.
     */
    private static final long serialVersionUID = 1L;

    /**
     * The money, not null.
     */
    private final BigMoney money;

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code Money} from a {@code BigDecimal}.
     * &lt;p&gt;
     * This allows you to create an instance with a specific currency and amount.
     * No rounding is performed on the amount, so it must have a scale compatible
     * with the currency.
     *
     * @param currency  the currency, not null
     * @param amount  the amount of money, not null
     * @return the new instance, never null
     * @throws ArithmeticException if the scale exceeds the currency scale
     */
    public static Money of(CurrencyUnit currency, BigDecimal amount) {
<span class="fc" id="L71">        MoneyUtils.checkNotNull(currency, &quot;Currency must not be null&quot;);</span>
<span class="fc" id="L72">        MoneyUtils.checkNotNull(amount, &quot;Amount must not be null&quot;);</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">        if (amount.scale() &gt; currency.getDecimalPlaces()) {</span>
<span class="fc" id="L74">            throw new ArithmeticException(&quot;Scale of amount &quot; + amount + &quot; is greater than the scale of the currency &quot; + currency);</span>
        }
<span class="fc" id="L76">        return Money.of(currency, amount, RoundingMode.UNNECESSARY);</span>
    }

    /**
     * Obtains an instance of {@code Money} from a {@code BigDecimal}, rounding as necessary.
     * &lt;p&gt;
     * This allows you to create an instance with a specific currency and amount.
     * If the amount has a scale in excess of the scale of the currency then the excess
     * fractional digits are rounded using the rounding mode.
     *
     * @param currency  the currency, not null
     * @param amount  the amount of money, not null
     * @param roundingMode  the rounding mode to use, not null
     * @return the new instance, never null
     * @throws ArithmeticException if the rounding fails
     */
    public static Money of(CurrencyUnit currency, BigDecimal amount, RoundingMode roundingMode) {
<span class="fc" id="L93">        MoneyUtils.checkNotNull(currency, &quot;CurrencyUnit must not be null&quot;);</span>
<span class="fc" id="L94">        MoneyUtils.checkNotNull(amount, &quot;Amount must not be null&quot;);</span>
<span class="fc" id="L95">        MoneyUtils.checkNotNull(roundingMode, &quot;RoundingMode must not be null&quot;);</span>
<span class="fc" id="L96">        var scaledAmount = amount.setScale(currency.getDecimalPlaces(), roundingMode);</span>
<span class="fc" id="L97">        return new Money(BigMoney.of(currency, scaledAmount));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code Money} from a {@code double} using a
     * well-defined conversion.
     * &lt;p&gt;
     * This allows you to create an instance with a specific currency and amount.
     * No rounding is performed on the amount, so it must have a scale compatible
     * with the currency.
     * &lt;p&gt;
     * The amount is converted via {@link BigDecimal#valueOf(double)} which yields
     * the most expected answer for most programming scenarios.
     * Any {@code double} literal in code will be converted to
     * exactly the same BigDecimal with the same scale.
     * For example, the literal '1.45d' will be converted to '1.45'.
     *
     * @param currency  the currency, not null
     * @param amount  the amount of money, not null
     * @return the new instance, never null
     * @throws ArithmeticException if the scale exceeds the currency scale
     */
    public static Money of(CurrencyUnit currency, double amount) {
<span class="fc" id="L121">        return Money.of(currency, BigDecimal.valueOf(amount));</span>
    }

    /**
     * Obtains an instance of {@code Money} from a {@code double} using a
     * well-defined conversion, rounding as necessary.
     * &lt;p&gt;
     * This allows you to create an instance with a specific currency and amount.
     * If the amount has a scale in excess of the scale of the currency then the excess
     * fractional digits are rounded using the rounding mode.
     * &lt;p&gt;
     * The amount is converted via {@link BigDecimal#valueOf(double)} which yields
     * the most expected answer for most programming scenarios.
     * Any {@code double} literal in code will be converted to
     * exactly the same BigDecimal with the same scale.
     * For example, the literal '1.45d' will be converted to '1.45'.
     *
     * @param currency  the currency, not null
     * @param amount  the amount of money, not null
     * @param roundingMode  the rounding mode to use, not null
     * @return the new instance, never null
     * @throws ArithmeticException if the rounding fails
     */
    public static Money of(CurrencyUnit currency, double amount, RoundingMode roundingMode) {
<span class="fc" id="L145">        return Money.of(currency, BigDecimal.valueOf(amount), roundingMode);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code Money} from an amount in major units.
     * &lt;p&gt;
     * This allows you to create an instance with a specific currency and amount.
     * The amount is a whole number only. Thus you can initialise the value
     * 'USD 20', but not the value 'USD 20.32'.
     * For example, {@code ofMajor(USD, 25)} creates the instance {@code USD 25.00}.
     *
     * @param currency  the currency, not null
     * @param amountMajor  the amount of money in the major division of the currency
     * @return the new instance, never null
     */
    public static Money ofMajor(CurrencyUnit currency, long amountMajor) {
<span class="fc" id="L162">        return Money.of(currency, BigDecimal.valueOf(amountMajor), RoundingMode.UNNECESSARY);</span>
    }

    /**
     * Obtains an instance of {@code Money} from an amount in minor units.
     * &lt;p&gt;
     * This allows you to create an instance with a specific currency and amount
     * expressed in terms of the minor unit.
     * For example, if constructing US Dollars, the input to this method represents cents.
     * Note that when a currency has zero decimal places, the major and minor units are the same.
     * For example, {@code ofMinor(USD, 2595)} creates the instance {@code USD 25.95}.
     *
     * @param currency  the currency, not null
     * @param amountMinor  the amount of money in the minor division of the currency
     * @return the new instance, never null
     */
    public static Money ofMinor(CurrencyUnit currency, long amountMinor) {
<span class="fc" id="L179">        return new Money(BigMoney.ofMinor(currency, amountMinor));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code Money} representing zero.
     * &lt;p&gt;
     * For example, {@code zero(USD)} creates the instance {@code USD 0.00}.
     *
     * @param currency  the currency, not null
     * @return the instance representing zero, never null
     */
    public static Money zero(CurrencyUnit currency) {
<span class="fc" id="L192">        MoneyUtils.checkNotNull(currency, &quot;Currency must not be null&quot;);</span>
<span class="fc" id="L193">        var bd = BigDecimal.valueOf(0, currency.getDecimalPlaces());</span>
<span class="fc" id="L194">        return new Money(BigMoney.of(currency, bd));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code Money} from a provider.
     * &lt;p&gt;
     * This allows you to create an instance from any class that implements the
     * provider, such as {@code BigMoney}.
     * No rounding is performed on the amount, so it must have a scale compatible
     * with the currency.
     *
     * @param moneyProvider  the money to convert, not null
     * @return the new instance, never null
     * @throws ArithmeticException if the scale exceeds the currency scale
     */
    public static Money of(BigMoneyProvider moneyProvider) {
<span class="fc" id="L211">        return Money.of(moneyProvider, RoundingMode.UNNECESSARY);</span>
    }

    /**
     * Obtains an instance of {@code Money} from a provider, rounding as necessary.
     * &lt;p&gt;
     * This allows you to create an instance from any class that implements the
     * provider, such as {@code BigMoney}.
     * The rounding mode is used to adjust the scale to the scale of the currency.
     *
     * @param moneyProvider  the money to convert, not null
     * @param roundingMode  the rounding mode to use, not null
     * @return the new instance, never null
     * @throws ArithmeticException if the rounding fails
     */
    public static Money of(BigMoneyProvider moneyProvider, RoundingMode roundingMode) {
<span class="fc" id="L227">        MoneyUtils.checkNotNull(moneyProvider, &quot;BigMoneyProvider must not be null&quot;);</span>
<span class="fc" id="L228">        MoneyUtils.checkNotNull(roundingMode, &quot;RoundingMode must not be null&quot;);</span>
<span class="fc" id="L229">        return new Money(BigMoney.of(moneyProvider).withCurrencyScale(roundingMode));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Obtains an instance of {@code Money} as the total value of an array.
     * &lt;p&gt;
     * The array must contain at least one monetary value.
     * Subsequent amounts are added as though using {@link #plus(Money)}.
     * All amounts must be in the same currency.
     *
     * @param monies  the monetary values to total, not empty, no null elements, not null
     * @return the total, never null
     * @throws IllegalArgumentException if the array is empty
     * @throws CurrencyMismatchException if the currencies differ
     */
    public static Money total(Money... monies) {
<span class="fc" id="L246">        MoneyUtils.checkNotNull(monies, &quot;Money array must not be null&quot;);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (monies.length == 0) {</span>
<span class="fc" id="L248">            throw new IllegalArgumentException(&quot;Money array must not be empty&quot;);</span>
        }
<span class="fc" id="L250">        var total = monies[0];</span>
<span class="fc" id="L251">        MoneyUtils.checkNotNull(total, &quot;Money arary must not contain null entries&quot;);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        for (var i = 1; i &lt; monies.length; i++) {</span>
<span class="fc" id="L253">            total = total.plus(monies[i]);</span>
        }
<span class="fc" id="L255">        return total;</span>
    }

    /**
     * Obtains an instance of {@code Money} as the total value of a collection.
     * &lt;p&gt;
     * The iterable must provide at least one monetary value.
     * Subsequent amounts are added as though using {@link #plus(Money)}.
     * All amounts must be in the same currency.
     *
     * @param monies  the monetary values to total, not empty, no null elements, not null
     * @return the total, never null
     * @throws IllegalArgumentException if the iterable is empty
     * @throws CurrencyMismatchException if the currencies differ
     */
    public static Money total(Iterable&lt;Money&gt; monies) {
<span class="fc" id="L271">        MoneyUtils.checkNotNull(monies, &quot;Money iterator must not be null&quot;);</span>
<span class="fc" id="L272">        var it = monies.iterator();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (!it.hasNext()) {</span>
<span class="fc" id="L274">            throw new IllegalArgumentException(&quot;Money iterator must not be empty&quot;);</span>
        }
<span class="fc" id="L276">        var total = it.next();</span>
<span class="fc" id="L277">        MoneyUtils.checkNotNull(total, &quot;Money iterator must not contain null entries&quot;);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        while (it.hasNext()) {</span>
<span class="fc" id="L279">            total = total.plus(it.next());</span>
        }
<span class="fc" id="L281">        return total;</span>
    }

    /**
     * Obtains an instance of {@code Money} as the total value of
     * a possibly empty array.
     * &lt;p&gt;
     * The amounts are added as though using {@link #plus(Money)} starting
     * from zero in the specified currency.
     * All amounts must be in the same currency.
     *
     * @param currency  the currency to total in, not null
     * @param monies  the monetary values to total, no null elements, not null
     * @return the total, never null
     * @throws CurrencyMismatchException if the currencies differ
     */
    public static Money total(CurrencyUnit currency, Money... monies) {
<span class="fc" id="L298">        return Money.zero(currency).plus(Arrays.asList(monies));</span>
    }

    /**
     * Obtains an instance of {@code Money} as the total value of
     * a possibly empty collection.
     * &lt;p&gt;
     * The amounts are added as though using {@link #plus(Money)} starting
     * from zero in the specified currency.
     * All amounts must be in the same currency.
     *
     * @param currency  the currency to total in, not null
     * @param monies  the monetary values to total, no null elements, not null
     * @return the total, never null
     * @throws CurrencyMismatchException if the currencies differ
     */
    public static Money total(CurrencyUnit currency, Iterable&lt;Money&gt; monies) {
<span class="fc" id="L315">        return Money.zero(currency).plus(monies);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Parses an instance of {@code Money} from a string.
     * &lt;p&gt;
     * The string format is '$currencyCode $amount' where there may be
     * zero to many spaces between the two parts.
     * The currency code must be a valid three letter currency.
     * The amount must match the regular expression {@code [+-]?[0-9]*[.]?[0-9]*}.
     * The spaces and numbers must be ASCII characters.
     * This matches the output from {@link #toString()}.
     * &lt;p&gt;
     * For example, {@code parse(&quot;USD 25&quot;)} creates the instance {@code USD 25.00}
     * while {@code parse(&quot;USD 25.95&quot;)} creates the instance {@code USD 25.95}.
     *
     * @param moneyStr  the money string to parse, not null
     * @return the parsed instance, never null
     * @throws IllegalArgumentException if the string is malformed
     * @throws ArithmeticException if the amount is too large
     */
    @FromString
    public static Money parse(String moneyStr) {
<span class="fc" id="L339">        return Money.of(BigMoney.parse(moneyStr));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Private no-args constructor, for use as JPA Embeddable (for example).
     */
    @SuppressWarnings(&quot;unused&quot;)
<span class="nc" id="L347">    private Money() {</span>
<span class="nc" id="L348">        this.money = null;</span>
<span class="nc" id="L349">    }</span>

    /**
     * Constructor, creating a new monetary instance.
     *
     * @param money  the underlying money, not null
     */
<span class="fc" id="L356">    Money(BigMoney money) {</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        assert money != null : &quot;Joda-Money bug: BigMoney must not be null&quot;;</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">        assert money.isCurrencyScale() : &quot;Joda-Money bug: Only currency scale is valid for Money&quot;;</span>
<span class="fc" id="L359">        this.money = money;</span>
<span class="fc" id="L360">    }</span>

    /**
     * Block malicious data streams.
     *
     * @param ois  the input stream, not null
     * @throws InvalidObjectException if an error occurs
     */
    private void readObject(ObjectInputStream ois) throws InvalidObjectException {
<span class="nc" id="L369">        throw new InvalidObjectException(&quot;Serialization delegate required&quot;);</span>
    }

    /**
     * Uses a serialization delegate.
     *
     * @return the replacing object, never null
     */
    private Object writeReplace() {
<span class="fc" id="L378">        return new Ser(Ser.MONEY, this);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a new {@code Money}, returning {@code this} if possible.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param newInstance  the new money to use, not null
     * @return the new instance, never null
     */
    private Money with(BigMoney newInstance) {
<span class="fc bfc" id="L391" title="All 2 branches covered.">        if (money.equals(newInstance)) {</span>
<span class="fc" id="L392">            return this;</span>
        }
<span class="fc" id="L394">        return new Money(newInstance);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the currency.
     *
     * @return the currency, never null
     */
    public CurrencyUnit getCurrencyUnit() {
<span class="fc" id="L404">        return money.getCurrencyUnit();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this monetary value with the specified currency.
     * &lt;p&gt;
     * The returned instance will have the specified currency and the amount
     * from this instance. If the scale differs between the currencies such
     * that rounding would be required, then an exception is thrown.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param currency  the currency to use, not null
     * @return the new instance with the input currency set, never null
     * @throws ArithmeticException if the scale of the new currency is less than
     *  the scale of this currency
     */
    public Money withCurrencyUnit(CurrencyUnit currency) {
<span class="fc" id="L423">        return withCurrencyUnit(currency, RoundingMode.UNNECESSARY);</span>
    }

    /**
     * Returns a copy of this monetary value with the specified currency.
     * &lt;p&gt;
     * The returned instance will have the specified currency and the amount
     * from this instance. If the number of decimal places differs between the
     * currencies, then the amount may be rounded.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param currency  the currency to use, not null
     * @param roundingMode  the rounding mode to use to bring the decimal places back in line, not null
     * @return the new instance with the input currency set, never null
     * @throws ArithmeticException if the rounding fails
     */
    public Money withCurrencyUnit(CurrencyUnit currency, RoundingMode roundingMode) {
<span class="fc" id="L441">        return with(money.withCurrencyUnit(currency).withCurrencyScale(roundingMode));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the scale of the {@code BigDecimal} amount.
     * &lt;p&gt;
     * The scale has the same meaning as in {@link BigDecimal}.
     * Positive values represent the number of decimal places in use.
     * For example, a scale of 2 means that the money will have two decimal places
     * such as 'USD 43.25'.
     * &lt;p&gt;
     * For {@code Money}, the scale is fixed and always matches that of the currency.
     *
     * @return the scale in use, typically 2 but could be 0, 1 and 3
     */
    public int getScale() {
<span class="fc" id="L458">        return money.getScale();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the amount.
     * &lt;p&gt;
     * This returns the value of the money as a {@code BigDecimal}.
     * The scale will be the scale of this money.
     *
     * @return the amount, never null
     */
    public BigDecimal getAmount() {
<span class="fc" id="L471">        return money.getAmount();</span>
    }

    /**
     * Gets the amount in major units as a {@code BigDecimal} with scale 0.
     * &lt;p&gt;
     * This returns the monetary amount in terms of the major units of the currency,
     * truncating the amount if necessary.
     * For example, 'EUR 2.35' will return 2, and 'BHD -1.345' will return -1.
     * &lt;p&gt;
     * This is returned as a {@code BigDecimal} rather than a {@code BigInteger}.
     * This is to allow further calculations to be performed on the result.
     * Should you need a {@code BigInteger}, simply call {@link BigDecimal#toBigInteger()}.
     *
     * @return the major units part of the amount, never null
     */
    public BigDecimal getAmountMajor() {
<span class="fc" id="L488">        return money.getAmountMajor();</span>
    }

    /**
     * Gets the amount in major units as a {@code long}.
     * &lt;p&gt;
     * This returns the monetary amount in terms of the major units of the currency,
     * truncating the amount if necessary.
     * For example, 'EUR 2.35' will return 2, and 'BHD -1.345' will return -1.
     *
     * @return the major units part of the amount
     * @throws ArithmeticException if the amount is too large for a {@code long}
     */
    public long getAmountMajorLong() {
<span class="fc" id="L502">        return money.getAmountMajorLong();</span>
    }

    /**
     * Gets the amount in major units as an {@code int}.
     * &lt;p&gt;
     * This returns the monetary amount in terms of the major units of the currency,
     * truncating the amount if necessary.
     * For example, 'EUR 2.35' will return 2, and 'BHD -1.345' will return -1.
     *
     * @return the major units part of the amount
     * @throws ArithmeticException if the amount is too large for an {@code int}
     */
    public int getAmountMajorInt() {
<span class="fc" id="L516">        return money.getAmountMajorInt();</span>
    }

    /**
     * Gets the amount in minor units as a {@code BigDecimal} with scale 0.
     * &lt;p&gt;
     * This returns the monetary amount in terms of the minor units of the currency,
     * truncating the amount if necessary.
     * For example, 'EUR 2.35' will return 235, and 'BHD -1.345' will return -1345.
     * &lt;p&gt;
     * This is returned as a {@code BigDecimal} rather than a {@code BigInteger}.
     * This is to allow further calculations to be performed on the result.
     * Should you need a {@code BigInteger}, simply call {@link BigDecimal#toBigInteger()}.
     *
     * @return the minor units part of the amount, never null
     */
    public BigDecimal getAmountMinor() {
<span class="fc" id="L533">        return money.getAmountMinor();</span>
    }

    /**
     * Gets the amount in minor units as a {@code long}.
     * &lt;p&gt;
     * This returns the monetary amount in terms of the minor units of the currency,
     * truncating the amount if necessary.
     * For example, 'EUR 2.35' will return 235, and 'BHD -1.345' will return -1345.
     *
     * @return the minor units part of the amount
     * @throws ArithmeticException if the amount is too large for a {@code long}
     */
    public long getAmountMinorLong() {
<span class="fc" id="L547">        return money.getAmountMinorLong();</span>
    }

    /**
     * Gets the amount in minor units as an {@code int}.
     * &lt;p&gt;
     * This returns the monetary amount in terms of the minor units of the currency,
     * truncating the amount if necessary.
     * For example, 'EUR 2.35' will return 235, and 'BHD -1.345' will return -1345.
     *
     * @return the minor units part of the amount
     * @throws ArithmeticException if the amount is too large for an {@code int}
     */
    public int getAmountMinorInt() {
<span class="fc" id="L561">        return money.getAmountMinorInt();</span>
    }

    /**
     * Gets the minor part of the amount.
     * &lt;p&gt;
     * This return the minor unit part of the monetary amount.
     * This is defined as the amount in minor units excluding major units.
     * &lt;p&gt;
     * For example, EUR has a scale of 2, so the minor part is always between 0 and 99
     * for positive amounts, and 0 and -99 for negative amounts.
     * Thus 'EUR 2.35' will return 35, and 'EUR -1.34' will return -34.
     *
     * @return the minor part of the amount, negative if the amount is negative
     */
    public int getMinorPart() {
<span class="fc" id="L577">        return money.getMinorPart();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if the amount is zero.
     *
     * @return true if the amount is zero
     */
    public boolean isZero() {
<span class="fc" id="L587">        return money.isZero();</span>
    }

    /**
     * Checks if the amount is greater than zero.
     *
     * @return true if the amount is greater than zero
     */
    public boolean isPositive() {
<span class="fc" id="L596">        return money.isPositive();</span>
    }

    /**
     * Checks if the amount is zero or greater.
     *
     * @return true if the amount is zero or greater
     */
    public boolean isPositiveOrZero() {
<span class="fc" id="L605">        return money.isPositiveOrZero();</span>
    }

    /**
     * Checks if the amount is less than zero.
     *
     * @return true if the amount is less than zero
     */
    public boolean isNegative() {
<span class="fc" id="L614">        return money.isNegative();</span>
    }

    /**
     * Checks if the amount is zero or less.
     *
     * @return true if the amount is zero or less
     */
    public boolean isNegativeOrZero() {
<span class="fc" id="L623">        return money.isNegativeOrZero();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this monetary value with the specified amount.
     * &lt;p&gt;
     * The returned instance will have this currency and the new amount.
     * No rounding is performed on the amount to be added, so it must have a
     * scale compatible with the currency.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amount  the monetary amount to set in the returned instance, not null
     * @return the new instance with the input amount set, never null
     * @throws ArithmeticException if the scale of the amount is too large
     */
    public Money withAmount(BigDecimal amount) {
<span class="fc" id="L641">        return withAmount(amount, RoundingMode.UNNECESSARY);</span>
    }

    /**
     * Returns a copy of this monetary value with the specified amount.
     * &lt;p&gt;
     * The returned instance will have this currency and the new amount.
     * If the scale of the {@code BigDecimal} needs to be adjusted, then
     * it will be rounded using the specified mode.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amount  the monetary amount to set in the returned instance, not null
     * @param roundingMode  the rounding mode to adjust the scale, not null
     * @return the new instance with the input amount set, never null
     */
    public Money withAmount(BigDecimal amount, RoundingMode roundingMode) {
<span class="fc" id="L658">        return with(money.withAmount(amount).withCurrencyScale(roundingMode));</span>
    }

    /**
     * Returns a copy of this monetary value with the specified amount using a well-defined
     * conversion from a {@code double}.
     * &lt;p&gt;
     * The returned instance will have this currency and the new amount.
     * No rounding is performed on the amount to be added, so it must have a
     * scale compatible with the currency.
     * &lt;p&gt;
     * The amount is converted via {@link BigDecimal#valueOf(double)} which yields
     * the most expected answer for most programming scenarios.
     * Any {@code double} literal in code will be converted to
     * exactly the same BigDecimal with the same scale.
     * For example, the literal '1.45d' will be converted to '1.45'.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amount  the monetary amount to set in the returned instance, not null
     * @return the new instance with the input amount set, never null
     * @throws ArithmeticException if the scale of the amount is too large
     */
    public Money withAmount(double amount) {
<span class="fc" id="L682">        return withAmount(amount, RoundingMode.UNNECESSARY);</span>
    }

    /**
     * Returns a copy of this monetary value with the specified amount using a well-defined
     * conversion from a {@code double}.
     * &lt;p&gt;
     * The returned instance will have this currency and the new amount.
     * If the scale of the {@code BigDecimal} needs to be adjusted, then
     * it will be rounded using the specified mode.
     * &lt;p&gt;
     * The amount is converted via {@link BigDecimal#valueOf(double)} which yields
     * the most expected answer for most programming scenarios.
     * Any {@code double} literal in code will be converted to
     * exactly the same BigDecimal with the same scale.
     * For example, the literal '1.45d' will be converted to '1.45'.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amount  the monetary amount to set in the returned instance, not null
     * @param roundingMode  the rounding mode to adjust the scale, not null
     * @return the new instance with the input amount set, never null
     */
    public Money withAmount(double amount, RoundingMode roundingMode) {
<span class="fc" id="L706">        return with(money.withAmount(amount).withCurrencyScale(roundingMode));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this monetary value with a collection of monetary amounts added.
     * &lt;p&gt;
     * This adds the specified amounts to this monetary amount, returning a new object.
     * The amounts must be in the same currency.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param moniesToAdd  the monetary values to add, no null elements, not null
     * @return the new instance with the input amounts added, never null
     * @throws CurrencyMismatchException if the currencies differ
     */
    public Money plus(Iterable&lt;Money&gt; moniesToAdd) {
<span class="fc" id="L723">        return with(money.plus(moniesToAdd));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this monetary value with the amount added.
     * &lt;p&gt;
     * This adds the specified amount to this monetary amount, returning a new object.
     * The amount added must be in the same currency.
     * &lt;p&gt;
     * The addition has no rounding issues and is always accurate.
     * For example,'USD 25.95' plus 'USD 3.02' will 'USD 28.97'.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param moneyToAdd  the monetary value to add, not null
     * @return the new instance with the input amount added, never null
     * @throws CurrencyMismatchException if the currencies differ
     */
    public Money plus(Money moneyToAdd) {
<span class="fc" id="L743">        return with(money.plus(moneyToAdd));</span>
    }

    /**
     * Returns a copy of this monetary value with the amount added.
     * &lt;p&gt;
     * This adds the specified amount to this monetary amount, returning a new object.
     * No rounding is performed on the amount to be added, so it must have a
     * scale compatible with the currency.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToAdd  the monetary value to add, not null
     * @return the new instance with the input amount added, never null
     * @throws ArithmeticException if the scale of the amount is too large
     */
    public Money plus(BigDecimal amountToAdd) {
<span class="fc" id="L760">        return plus(amountToAdd, RoundingMode.UNNECESSARY);</span>
    }

    /**
     * Returns a copy of this monetary value with the amount added.
     * &lt;p&gt;
     * This adds the specified amount to this monetary amount, returning a new object.
     * If the amount to add exceeds the scale of the currency, then the
     * rounding mode will be used to adjust the result.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToAdd  the monetary value to add, not null
     * @param roundingMode  the rounding mode to use, not null
     * @return the new instance with the input amount added, never null
     */
    public Money plus(BigDecimal amountToAdd, RoundingMode roundingMode) {
<span class="fc" id="L777">        return with(money.plusRetainScale(amountToAdd, roundingMode));</span>
    }

    /**
     * Returns a copy of this monetary value with the amount added.
     * &lt;p&gt;
     * This adds the specified amount to this monetary amount, returning a new object.
     * No rounding is performed on the amount to be added, so it must have a
     * scale compatible with the currency.
     * &lt;p&gt;
     * The amount is converted via {@link BigDecimal#valueOf(double)} which yields
     * the most expected answer for most programming scenarios.
     * Any {@code double} literal in code will be converted to
     * exactly the same BigDecimal with the same scale.
     * For example, the literal '1.45d' will be converted to '1.45'.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToAdd  the monetary value to add, not null
     * @return the new instance with the input amount added, never null
     * @throws ArithmeticException if the scale of the amount is too large
     */
    public Money plus(double amountToAdd) {
<span class="fc" id="L800">        return plus(amountToAdd, RoundingMode.UNNECESSARY);</span>
    }

    /**
     * Returns a copy of this monetary value with the amount added.
     * &lt;p&gt;
     * This adds the specified amount to this monetary amount, returning a new object.
     * If the amount to add exceeds the scale of the currency, then the
     * rounding mode will be used to adjust the result.
     * &lt;p&gt;
     * The amount is converted via {@link BigDecimal#valueOf(double)} which yields
     * the most expected answer for most programming scenarios.
     * Any {@code double} literal in code will be converted to
     * exactly the same BigDecimal with the same scale.
     * For example, the literal '1.45d' will be converted to '1.45'.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToAdd  the monetary value to add, not null
     * @param roundingMode  the rounding mode to use, not null
     * @return the new instance with the input amount added, never null
     */
    public Money plus(double amountToAdd, RoundingMode roundingMode) {
<span class="fc" id="L823">        return with(money.plusRetainScale(amountToAdd, roundingMode));</span>
    }

    /**
     * Returns a copy of this monetary value with the amount in major units added.
     * &lt;p&gt;
     * This adds an amount in major units, leaving the minor units untouched.
     * For example, USD 23.45 plus 138 gives USD 161.45.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToAdd  the monetary value to add, not null
     * @return the new instance with the input amount added, never null
     */
    public Money plusMajor(long amountToAdd) {
<span class="fc" id="L838">        return with(money.plusMajor(amountToAdd));</span>
    }

    /**
     * Returns a copy of this monetary value with the amount in minor units added.
     * &lt;p&gt;
     * This adds an amount in minor units.
     * For example, USD 23.45 plus 138 gives USD 24.83.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToAdd  the monetary value to add, not null
     * @return the new instance with the input amount added, never null
     */
    public Money plusMinor(long amountToAdd) {
<span class="fc" id="L853">        return with(money.plusMinor(amountToAdd));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this monetary value with a collection of monetary amounts subtracted.
     * &lt;p&gt;
     * This subtracts the specified amounts from this monetary amount, returning a new object.
     * The amounts must be in the same currency.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param moniesToSubtract  the monetary values to subtract, no null elements, not null
     * @return the new instance with the input amounts subtracted, never null
     * @throws CurrencyMismatchException if the currencies differ
     */
    public Money minus(Iterable&lt;Money&gt; moniesToSubtract) {
<span class="fc" id="L870">        return with(money.minus(moniesToSubtract));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this monetary value with the amount subtracted.
     * &lt;p&gt;
     * This subtracts the specified amount from this monetary amount, returning a new object.
     * The amount subtracted must be in the same currency.
     * &lt;p&gt;
     * The subtraction has no rounding issues and is always accurate.
     * For example,'USD 25.95' minus 'USD 3.02' will 'USD 22.93'.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param moneyToSubtract  the monetary value to subtract, not null
     * @return the new instance with the input amount subtracted, never null
     * @throws CurrencyMismatchException if the currencies differ
     */
    public Money minus(Money moneyToSubtract) {
<span class="fc" id="L890">        return with(money.minus(moneyToSubtract));</span>
    }

    /**
     * Returns a copy of this monetary value with the amount subtracted.
     * &lt;p&gt;
     * This subtracts the specified amount from this monetary amount, returning a new object.
     * No rounding is performed on the amount to be subtracted, so it must have a
     * scale compatible with the currency.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToSubtract  the monetary value to subtract, not null
     * @return the new instance with the input amount subtracted, never null
     * @throws ArithmeticException if the scale of the amount is too large
     */
    public Money minus(BigDecimal amountToSubtract) {
<span class="fc" id="L907">        return minus(amountToSubtract, RoundingMode.UNNECESSARY);</span>
    }

    /**
     * Returns a copy of this monetary value with the amount subtracted.
     * &lt;p&gt;
     * This subtracts the specified amount from this monetary amount, returning a new object.
     * If the amount to subtract exceeds the scale of the currency, then the
     * rounding mode will be used to adjust the result.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToSubtract  the monetary value to subtract, not null
     * @param roundingMode  the rounding mode to use, not null
     * @return the new instance with the input amount subtracted, never null
     */
    public Money minus(BigDecimal amountToSubtract, RoundingMode roundingMode) {
<span class="fc" id="L924">        return with(money.minusRetainScale(amountToSubtract, roundingMode));</span>
    }

    /**
     * Returns a copy of this monetary value with the amount subtracted.
     * &lt;p&gt;
     * This subtracts the specified amount from this monetary amount, returning a new object.
     * No rounding is performed on the amount to be subtracted, so it must have a
     * scale compatible with the currency.
     * &lt;p&gt;
     * The amount is converted via {@link BigDecimal#valueOf(double)} which yields
     * the most expected answer for most programming scenarios.
     * Any {@code double} literal in code will be converted to
     * exactly the same BigDecimal with the same scale.
     * For example, the literal '1.45d' will be converted to '1.45'.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToSubtract  the monetary value to subtract, not null
     * @return the new instance with the input amount subtracted, never null
     * @throws ArithmeticException if the scale of the amount is too large
     */
    public Money minus(double amountToSubtract) {
<span class="fc" id="L947">        return minus(amountToSubtract, RoundingMode.UNNECESSARY);</span>
    }

    /**
     * Returns a copy of this monetary value with the amount subtracted.
     * &lt;p&gt;
     * This subtracts the specified amount from this monetary amount, returning a new object.
     * If the amount to subtract exceeds the scale of the currency, then the
     * rounding mode will be used to adjust the result.
     * &lt;p&gt;
     * The amount is converted via {@link BigDecimal#valueOf(double)} which yields
     * the most expected answer for most programming scenarios.
     * Any {@code double} literal in code will be converted to
     * exactly the same BigDecimal with the same scale.
     * For example, the literal '1.45d' will be converted to '1.45'.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToSubtract  the monetary value to subtract, not null
     * @param roundingMode  the rounding mode to use, not null
     * @return the new instance with the input amount subtracted, never null
     */
    public Money minus(double amountToSubtract, RoundingMode roundingMode) {
<span class="fc" id="L970">        return with(money.minusRetainScale(amountToSubtract, roundingMode));</span>
    }

    /**
     * Returns a copy of this monetary value with the amount in major units subtracted.
     * &lt;p&gt;
     * This subtracts an amount in major units, leaving the minor units untouched.
     * For example, USD 23.45 minus 138 gives USD -114.55.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToSubtract  the monetary value to subtract, not null
     * @return the new instance with the input amount subtracted, never null
     */
    public Money minusMajor(long amountToSubtract) {
<span class="fc" id="L985">        return with(money.minusMajor(amountToSubtract));</span>
    }

    /**
     * Returns a copy of this monetary value with the amount in minor units subtracted.
     * &lt;p&gt;
     * This subtracts an amount in minor units.
     * For example, USD 23.45 minus 138 gives USD 22.07.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param amountToSubtract  the monetary value to subtract, not null
     * @return the new instance with the input amount subtracted, never null
     */
    public Money minusMinor(long amountToSubtract) {
<span class="fc" id="L1000">        return with(money.minusMinor(amountToSubtract));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this monetary value multiplied by the specified value.
     * &lt;p&gt;
     * This takes this amount and multiplies it by the specified value, rounding
     * the result is rounded as specified.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param valueToMultiplyBy  the scalar value to multiply by, not null
     * @param roundingMode  the rounding mode to use to bring the decimal places back in line, not null
     * @return the new multiplied instance, never null
     * @throws ArithmeticException if the rounding fails
     */
    public Money multipliedBy(BigDecimal valueToMultiplyBy, RoundingMode roundingMode) {
<span class="fc" id="L1018">        return with(money.multiplyRetainScale(valueToMultiplyBy, roundingMode));</span>
    }

    /**
     * Returns a copy of this monetary value multiplied by the specified value.
     * &lt;p&gt;
     * This takes this amount and multiplies it by the specified value, rounding
     * the result is rounded as specified.
     * &lt;p&gt;
     * The amount is converted via {@link BigDecimal#valueOf(double)} which yields
     * the most expected answer for most programming scenarios.
     * Any {@code double} literal in code will be converted to
     * exactly the same BigDecimal with the same scale.
     * For example, the literal '1.45d' will be converted to '1.45'.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param valueToMultiplyBy  the scalar value to multiply by, not null
     * @param roundingMode  the rounding mode to use to bring the decimal places back in line, not null
     * @return the new multiplied instance, never null
     * @throws ArithmeticException if the rounding fails
     */
    public Money multipliedBy(double valueToMultiplyBy, RoundingMode roundingMode) {
<span class="fc" id="L1041">        return with(money.multiplyRetainScale(valueToMultiplyBy, roundingMode));</span>
    }

    /**
     * Returns a copy of this monetary value multiplied by the specified value.
     * &lt;p&gt;
     * This takes this amount and multiplies it by the specified value.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param valueToMultiplyBy  the scalar value to multiply by, not null
     * @return the new multiplied instance, never null
     */
    public Money multipliedBy(long valueToMultiplyBy) {
<span class="fc" id="L1055">        return with(money.multipliedBy(valueToMultiplyBy));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this monetary value divided by the specified value.
     * &lt;p&gt;
     * This takes this amount and divides it by the specified value, rounding
     * the result is rounded as specified.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param valueToDivideBy  the scalar value to divide by, not null
     * @param roundingMode  the rounding mode to use, not null
     * @return the new divided instance, never null
     * @throws ArithmeticException if dividing by zero
     * @throws ArithmeticException if the rounding fails
     */
    public Money dividedBy(BigDecimal valueToDivideBy, RoundingMode roundingMode) {
<span class="fc" id="L1074">        return with(money.dividedBy(valueToDivideBy, roundingMode));</span>
    }

    /**
     * Returns a copy of this monetary value divided by the specified value.
     * &lt;p&gt;
     * This takes this amount and divides it by the specified value, rounding
     * the result is rounded as specified.
     * &lt;p&gt;
     * The amount is converted via {@link BigDecimal#valueOf(double)} which yields
     * the most expected answer for most programming scenarios.
     * Any {@code double} literal in code will be converted to
     * exactly the same BigDecimal with the same scale.
     * For example, the literal '1.45d' will be converted to '1.45'.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param valueToDivideBy  the scalar value to divide by, not null
     * @param roundingMode  the rounding mode to use, not null
     * @return the new divided instance, never null
     * @throws ArithmeticException if dividing by zero
     * @throws ArithmeticException if the rounding fails
     */
    public Money dividedBy(double valueToDivideBy, RoundingMode roundingMode) {
<span class="fc" id="L1098">        return with(money.dividedBy(valueToDivideBy, roundingMode));</span>
    }

    /**
     * Returns a copy of this monetary value divided by the specified value.
     * &lt;p&gt;
     * This takes this amount and divides it by the specified value, rounding
     * the result is rounded as specified.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param valueToDivideBy  the scalar value to divide by, not null
     * @param roundingMode  the rounding mode to use, not null
     * @return the new divided instance, never null
     * @throws ArithmeticException if dividing by zero
     * @throws ArithmeticException if the rounding fails
     */
    public Money dividedBy(long valueToDivideBy, RoundingMode roundingMode) {
<span class="fc" id="L1116">        return with(money.dividedBy(valueToDivideBy, roundingMode));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this monetary value with the amount negated.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @return the new instance with the amount negated, never null
     */
    public Money negated() {
<span class="fc" id="L1128">        return with(money.negated());</span>
    }

    /**
     * Returns a copy of this monetary value with a positive amount.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @return the new instance with the amount converted to be positive, never null
     */
    public Money abs() {
<span class="fc bfc" id="L1139" title="All 2 branches covered.">        return (isNegative() ? negated() : this);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this monetary value rounded to the specified scale without
     * changing the current scale.
     * &lt;p&gt;
     * Scale has the same meaning as in {@link BigDecimal}.
     * A scale of 2 means round to 2 decimal places.
     * &lt;ul&gt;
     * &lt;li&gt;Rounding 'EUR 45.23' to a scale of -1 returns 40.00 or 50.00 depending on the rounding mode.
     * &lt;li&gt;Rounding 'EUR 45.23' to a scale of 0 returns 45.00 or 46.00 depending on the rounding mode.
     * &lt;li&gt;Rounding 'EUR 45.23' to a scale of 1 returns 45.20 or 45.30 depending on the rounding mode.
     * &lt;li&gt;Rounding 'EUR 45.23' to a scale of 2 has no effect (it already has that scale).
     * &lt;li&gt;Rounding 'EUR 45.23' to a scale of 3 has no effect (the scale is not increased).
     * &lt;/ul&gt;
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param scale  the new scale
     * @param roundingMode  the rounding mode to use, not null
     * @return the new instance with the amount converted to be positive, never null
     * @throws ArithmeticException if the rounding fails
     */
    public Money rounded(int scale, RoundingMode roundingMode) {
<span class="fc" id="L1165">        return with(money.rounded(scale, roundingMode));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a copy of this monetary value converted into another currency
     * using the specified conversion rate, with a rounding mode used to adjust
     * the decimal places in the result.
     * &lt;p&gt;
     * This instance is immutable and unaffected by this method.
     *
     * @param currency  the new currency, not null
     * @param conversionMultipler  the conversion factor between the currencies, not null
     * @param roundingMode  the rounding mode to use to bring the decimal places back in line, not null
     * @return the new multiplied instance, never null
     * @throws IllegalArgumentException if the currency is the same as this currency
     * @throws IllegalArgumentException if the conversion multiplier is negative
     * @throws ArithmeticException if the rounding fails
     */
    public Money convertedTo(CurrencyUnit currency, BigDecimal conversionMultipler, RoundingMode roundingMode) {
<span class="fc" id="L1185">        return with(money.convertedTo(currency, conversionMultipler).withCurrencyScale(roundingMode));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Implements the {@code BigMoneyProvider} interface, returning a
     * {@code BigMoney} instance with the same currency, amount and scale.
     *
     * @return the money instance, never null
     */
    @Override
    public BigMoney toBigMoney() {
<span class="fc" id="L1197">        return money;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this instance and the specified instance have the same currency.
     *
     * @param other  the money to check, not null
     * @return true if they have the same currency
     */
    public boolean isSameCurrency(BigMoneyProvider other) {
<span class="fc" id="L1208">        return money.isSameCurrency(other);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Compares this monetary value to another.
     * &lt;p&gt;
     * This allows {@code Money} to be compared to any {@code BigMoneyProvider}.
     * Scale is ignored in the comparison.
     * The compared values must be in the same currency.
     *
     * @param other  the other monetary value, not null
     * @return -1 if this is less than , 0 if equal, 1 if greater than
     * @throws CurrencyMismatchException if the currencies differ
     */
    @Override
    public int compareTo(BigMoneyProvider other) {
<span class="fc" id="L1225">        return money.compareTo(other);</span>
    }

    /**
     * Checks if this monetary value is equal to another.
     * &lt;p&gt;
     * This allows {@code Money} to be compared to any {@code BigMoneyProvider}.
     * Scale is ignored, so 'USD 30.00' and 'USD 30' are equal.
     * The compared values must be in the same currency.
     *
     * @param other  the other monetary value, not null
     * @return true is this is greater than the specified monetary value
     * @throws CurrencyMismatchException if the currencies differ
     * @see #equals(Object)
     */
    public boolean isEqual(BigMoneyProvider other) {
<span class="fc" id="L1241">        return money.isEqual(other);</span>
    }

    /**
     * Checks if this monetary value is greater than another.
     * &lt;p&gt;
     * This allows {@code Money} to be compared to any {@code BigMoneyProvider}.
     * Scale is ignored in the comparison.
     * The compared values must be in the same currency.
     *
     * @param other  the other monetary value, not null
     * @return true is this is greater than the specified monetary value
     * @throws CurrencyMismatchException if the currencies differ
     */
    public boolean isGreaterThan(BigMoneyProvider other) {
<span class="fc" id="L1256">        return money.isGreaterThan(other);</span>
    }

    /**
     * Checks if this monetary value is greater than or equal to another.
     * &lt;p&gt;
     * This allows {@code Money} to be compared to any {@code BigMoneyProvider}.
     * Scale is ignored in the comparison.
     * The compared values must be in the same currency.
     *
     * @param other  the other monetary value, not null
     * @return true is this is greater than or equal to the specified monetary value
     * @throws CurrencyMismatchException if the currencies differ
     */
    public boolean isGreaterThanOrEqual(BigMoneyProvider other) {
<span class="fc" id="L1271">        return money.isGreaterThanOrEqual(other);</span>
    }

    /**
     * Checks if this monetary value is less than another.
     * &lt;p&gt;
     * This allows {@code Money} to be compared to any {@code BigMoneyProvider}.
     * Scale is ignored in the comparison.
     * The compared values must be in the same currency.
     *
     * @param other  the other monetary value, not null
     * @return true is this is less than the specified monetary value
     * @throws CurrencyMismatchException if the currencies differ
     */
    public boolean isLessThan(BigMoneyProvider other) {
<span class="fc" id="L1286">        return money.isLessThan(other);</span>
    }

    /**
     * Checks if this monetary value is less than or equal to another.
     * &lt;p&gt;
     * This allows {@code Money} to be compared to any {@code BigMoneyProvider}.
     * Scale is ignored in the comparison.
     * The compared values must be in the same currency.
     *
     * @param other  the other monetary value, not null
     * @return true is this is less than or equal to the specified monetary value
     * @throws CurrencyMismatchException if the currencies differ
     */
    public boolean isLessThanOrEqual(BigMoneyProvider other) {
<span class="fc" id="L1301">        return money.isLessThanOrEqual(other);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this monetary value equals another.
     * &lt;p&gt;
     * The comparison takes into account the scale.
     * The compared values must be in the same currency.
     *
     * @param other  the other object to compare to, not null
     * @return true if this instance equals the other instance
     */
    @Override
    public boolean equals(Object other) {
<span class="fc bfc" id="L1316" title="All 2 branches covered.">        if (this == other) {</span>
<span class="fc" id="L1317">            return true;</span>
        }
<span class="fc bfc" id="L1319" title="All 2 branches covered.">        if (other instanceof Money otherMoney) {</span>
<span class="fc" id="L1320">            return money.equals(otherMoney.money);</span>
        }
<span class="fc" id="L1322">        return false;</span>
    }

    /**
     * Returns a hash code for this monetary value.
     *
     * @return a suitable hash code
     */
    @Override
    public int hashCode() {
<span class="fc" id="L1332">        return money.hashCode() + 3;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the monetary value as a string.
     * &lt;p&gt;
     * The format is the 3 letter ISO currency code, followed by a space,
     * followed by the amount as per {@link BigDecimal#toPlainString()}.
     *
     * @return the string representation of this monetary value, never null
     */
    @Override
    @ToString
    public String toString() {
<span class="fc" id="L1347">        return money.toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>