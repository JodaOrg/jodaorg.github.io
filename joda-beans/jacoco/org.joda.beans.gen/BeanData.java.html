<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanData.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda-Beans</a> &gt; <a href="index.source.html" class="el_package">org.joda.beans.gen</a> &gt; <span class="el_source">BeanData.java</span></div><h1>BeanData.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-present Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.beans.gen;

import java.util.ArrayList;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * A bean that can be generated.
 */
class BeanData {

    /** The list of current imports. */
<span class="nc" id="L29">    private final SortedSet&lt;String&gt; currentImports = new TreeSet&lt;&gt;();</span>
    /** The list of new imports. */
<span class="nc" id="L31">    private final SortedSet&lt;String&gt; newImports = new TreeSet&lt;&gt;();</span>
    /** The last import line. */
    private int lastImportLine;
    /** The bean style. */
    private String beanStyle;
    /** The bean meta scope. */
    private String beanMetaScope;
    /** The bean meta implements. */
    private String beanMetaImplements;
    /** The bean builder scope. */
    private String beanBuilderScope;
    /** The bean builder style. */
    private String beanBuilderName;
    /** The factory method name. */
    private String factoryName;
    /** Whether to cache the hash code. */
    private boolean cacheHashCode;
    /** Whether the class is immutable. */
    private boolean immutable;
    /** Whether the class can be constructed. */
    private boolean constructable;
    /** Whether the class has a manual constructor for immutable beans. */
    private int immutableConstructor;
    /** The method name of the immutable validator. */
    private String immutableValidator;
    /** The method name of the immutable defaults. */
    private String immutableDefaults;
    /** The method name of the immutable pre-build. */
    private String immutablePreBuild;
    /** The style of constructor to generate. */
    private int constructorStyle;
    /** The generated constructor scope. */
    private String constructorScope;
    /** The full type of the bean class. */
    private String typeFull;
    /** The simple name of the bean class. */
    private String typeRaw;
    /** The name clause of the generic. */
    private String[] typeGenericName;
    /** The extends clause of the generic. */
    private String[] typeGenericExtends;
    /** Whether the type is final with no subclasses. */
    private boolean typeFinal;
    /** The scope of the type. */
    private String typeScope;
    /** Whether the type is a root with no bean super-classes. */
    private boolean root;
    /** The full name of the bean superclass. */
    private String superTypeFull;
    /** The simple name of the bean superclass. */
    private String superTypeRaw;
    /** The generic argument of the bean superclass. */
    private String superTypeGeneric;
    /** The list of properties, in the order they are declared. */
<span class="nc" id="L85">    private List&lt;PropertyData&gt; properties = new ArrayList&lt;&gt;();</span>
    /** The serializable flag. */
    private boolean serializable;
    /** The manual serialization version id flag. */
    private boolean manualSerVersionId;
    /** Does the class have a manual clone. */
    private boolean manualClone;
    /** Does the class have a manual equals or hash code. */
    private boolean manualEqualsHashCode;
    /** Does the class have a manual toString. */
    private boolean manualToStringCode;
    /** The style for Object#clone */
    private String cloneStyle;

    /**
     * Constructor.
     */
<span class="nc" id="L102">    BeanData() {</span>
<span class="nc" id="L103">    }</span>

    /**
     * Gets the current set of imports.
     * @return the imports
     */
    public SortedSet&lt;String&gt; getCurrentImports() {
<span class="nc" id="L110">        return currentImports;</span>
    }

    /**
     * Gets the new imports.
     * @return the imports
     */
    public SortedSet&lt;String&gt; getNewImports() {
<span class="nc" id="L118">        return newImports;</span>
    }

    /**
     * Ensures an import is present.
     * @param cls  the class, not null
     */
    public void ensureImport(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (currentImports.contains(cls.getName()) == false) {</span>
<span class="nc" id="L127">            newImports.add(cls.getName());</span>
        }
<span class="nc" id="L129">    }</span>

    /**
     * Gets the import insert location.
     * @return the insert location
     */
    public int getImportInsertLocation() {
<span class="nc" id="L136">        return lastImportLine;</span>
    }

    /**
     * Sets the import insert location.
     * @param location  the insert location
     */
    public void setImportInsertLocation(int location) {
<span class="nc" id="L144">        lastImportLine = location;</span>
<span class="nc" id="L145">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets the bean style.
     * @return the flag
     */
    public String getBeanStyle() {
<span class="nc" id="L153">        return beanStyle;</span>
    }

    /**
     * Sets the bean style.
     * @param beanStyle  the flag
     */
    public void setBeanStyle(String beanStyle) {
<span class="nc" id="L161">        this.beanStyle = beanStyle;</span>
<span class="nc" id="L162">    }</span>

    /**
     * Resolves the bean style.
     * @param defaultStyle  the default style
     */
    public void resolveBeanStyle(String defaultStyle) {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(beanStyle)) {</span>
<span class="nc" id="L170">            setBeanStyle(defaultStyle);</span>
        }
<span class="nc" id="L172">    }</span>

    /**
     * Is the bean style indicating that properties should be generated.
     * @return the flag
     */
    public boolean isBeanStyleValid() {
<span class="nc bnc" id="L179" title="All 4 branches missed.">        return &quot;full&quot;.equals(beanStyle) || &quot;smart&quot;.equals(beanStyle) ||</span>
<span class="nc bnc" id="L180" title="All 4 branches missed.">                &quot;minimal&quot;.equals(beanStyle) || &quot;light&quot;.equals(beanStyle);</span>
    }

    /**
     * Is the bean style indicating that no meta and builder should be generated.
     * @return the flag
     */
    public boolean isBeanStyleLight() {
<span class="nc" id="L188">        return &quot;light&quot;.equals(beanStyle);</span>
    }

    /**
     * Is the bean style minimal.
     * @return the flag
     */
    public boolean isBeanStyleMinimal() {
<span class="nc" id="L196">        return &quot;minimal&quot;.equals(beanStyle);</span>
    }

    /**
     * Is the bean style indicating that no meta and builder should be generated.
     * @return the flag
     */
    public boolean isBeanStyleLightOrMinimal() {
<span class="nc bnc" id="L204" title="All 4 branches missed.">        return isBeanStyleLight() || isBeanStyleMinimal();</span>
    }

    /**
     * Is the bean style indicating that properties should be generated.
     * @return the flag
     */
    public boolean isBeanStyleGenerateProperties() {
<span class="nc bnc" id="L212" title="All 6 branches missed.">        return &quot;full&quot;.equals(beanStyle) || (&quot;smart&quot;.equals(beanStyle) &amp;&amp; isImmutable() == false);</span>
    }

    /**
     * Is the bean style indicating that properties should be generated.
     * @return the flag
     */
    public boolean isBeanStyleGenerateMetaProperties() {
<span class="nc bnc" id="L220" title="All 6 branches missed.">        return (&quot;full&quot;.equals(beanStyle) || &quot;smart&quot;.equals(beanStyle)) &amp;&amp; !isMetaScopePrivate();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the bean meta scope.
     * @return the scope
     */
    public String getBeanMetaScope() {
<span class="nc" id="L229">        return beanMetaScope;</span>
    }

    /**
     * Sets the bean meta scope.
     * @param metaScope  the scope
     */
    public void setBeanMetaScope(String metaScope) {
<span class="nc" id="L237">        this.beanMetaScope = metaScope;</span>
<span class="nc" id="L238">    }</span>

    /**
     * Is the meta scope valid.
     * @return the flag
     */
    public boolean isBeanMetaScopeValid() {
<span class="nc bnc" id="L245" title="All 2 branches missed.">        return &quot;smart&quot;.equals(beanMetaScope) ||</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                &quot;private&quot;.equals(beanMetaScope) ||</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">                &quot;package&quot;.equals(beanMetaScope) ||</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">                &quot;public&quot;.equals(beanMetaScope);</span>
    }

    /**
     * Gets the effective scope to use in the meta.
     * @return the scope
     */
    public String getEffectiveMetaScope() {
<span class="nc" id="L256">        String scope = beanMetaScope;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(scope)) {</span>
<span class="nc" id="L258">            scope = typeScope;</span>
        }
<span class="nc bnc" id="L260" title="All 2 branches missed.">        return &quot;package&quot;.equals(scope) ? &quot;&quot; : scope + &quot; &quot;;</span>
    }

    /**
     * Checks the meta-bean scope.
     * @return the scope
     */
    public boolean isMetaScopePrivate() {
<span class="nc bnc" id="L268" title="All 4 branches missed.">        return &quot;private&quot;.equals(beanMetaScope) || isBeanStyleLight();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the bean meta implements.
     * @return the meta implements
     */
    public String getBeanMetaImplements() {
<span class="nc" id="L277">        return beanMetaImplements;</span>
    }

    /**
     * Sets the bean meta implements.
     * @param metaImplements  the meta implements
     */
    public void setBeanMetaImplements(String metaImplements) {
<span class="nc" id="L285">        this.beanMetaImplements = metaImplements;</span>
<span class="nc" id="L286">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets the bean builder scope.
     * @return the scope
     */
    public String getBeanBuilderScope() {
<span class="nc" id="L294">        return beanBuilderScope;</span>
    }

    /**
     * Sets the bean builder scope.
     * @param builderScope  the scope
     */
    public void setBeanBuilderScope(String builderScope) {
<span class="nc" id="L302">        this.beanBuilderScope = builderScope;</span>
<span class="nc" id="L303">    }</span>

    /**
     * Is the builder scope valid.
     * @return the flag
     */
    public boolean isBeanBuilderScopeValid() {
<span class="nc bnc" id="L310" title="All 2 branches missed.">        return &quot;smart&quot;.equals(beanBuilderScope) ||</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                &quot;private&quot;.equals(beanBuilderScope) ||</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                &quot;package&quot;.equals(beanBuilderScope) ||</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">                &quot;public&quot;.equals(beanBuilderScope);</span>
    }

    /**
     * Gets the effective scope to use in the builder.
     * @return the scope
     */
    public String getEffectiveBuilderScope() {
<span class="nc" id="L321">        String scope = beanBuilderScope;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(scope)) {</span>
<span class="nc" id="L323">            scope = typeScope;</span>
        }
<span class="nc bnc" id="L325" title="All 2 branches missed.">        return &quot;package&quot;.equals(scope) ? &quot;&quot; : scope + &quot; &quot;;</span>
    }

    /**
     * Is the effective scope to use in the builder public.
     * @return the scope
     */
    public boolean isEffectiveBuilderScopeVisible() {
<span class="nc bnc" id="L333" title="All 6 branches missed.">        return (&quot;smart&quot;.equals(beanBuilderScope) || &quot;public&quot;.equals(beanBuilderScope) || &quot;package&quot;.equals(beanBuilderScope)) &amp;&amp;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                !isBeanStyleLight();</span>
    }

    /**
     * Is the scope to use in the builder public.
     * @return the scope
     */
    public boolean isBuilderScopeVisible() {
<span class="nc bnc" id="L342" title="All 4 branches missed.">        return &quot;public&quot;.equals(beanBuilderScope) || &quot;package&quot;.equals(beanBuilderScope);</span>
    }

    /**
     * Is the builder generated
     * @return true if generated
     */
    public boolean isBuilderGenerated() {
<span class="nc bnc" id="L350" title="All 8 branches missed.">        return (isImmutable() &amp;&amp; isEffectiveBuilderScopeVisible()) || (isMutable() &amp;&amp; isBuilderScopeVisible());</span>
    }

    /**
     * Is the builder generated
     * @return true if generated
     */
    public boolean isSkipBuilderGeneration() {
<span class="nc bnc" id="L358" title="All 8 branches missed.">        return (isMutable() &amp;&amp; isBuilderScopeVisible() == false) || isBeanStyleLight() || isBeanBuilderManual();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the bean builder class name.
     * @return the class name
     */
    public String getBeanBuilderName() {
<span class="nc" id="L367">        return beanBuilderName;</span>
    }

    /**
     * Sets the bean builder class name.
     * @param builderName  the class name
     */
    public void setBeanBuilderName(String builderName) {
<span class="nc" id="L375">        this.beanBuilderName = builderName;</span>
<span class="nc" id="L376">    }</span>

    /**
     * Is the builder style manual.
     * @return the flag
     */
    public boolean isBeanBuilderManual() {
<span class="nc bnc" id="L383" title="All 2 branches missed.">        return !beanBuilderName.isEmpty();</span>
    }

    /**
     * Gets the effective bean builder.
     * @return the name
     */
    public String getEffectiveBeanBuilderName() {
<span class="nc bnc" id="L391" title="All 2 branches missed.">        return beanBuilderName.isEmpty() ? getTypeRaw() + &quot;.Builder&quot; : beanBuilderName;</span>
    }

    /**
     * Gets the effective bean builder.
     * @return the name
     */
    public String getEffectiveMinimalBeanBuilderName() {
<span class="nc bnc" id="L399" title="All 2 branches missed.">        return beanBuilderName.isEmpty() ? &quot;Builder&quot; : beanBuilderName;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the factory name.
     * @return the factory name
     */
    public boolean isFactoryRequired() {
<span class="nc bnc" id="L408" title="All 2 branches missed.">        return factoryName.length() &gt; 0;</span>
    }

    /**
     * Gets the factory name.
     * @return the factory name
     */
    public String getFactoryName() {
<span class="nc" id="L416">        return factoryName;</span>
    }

    /**
     * Sets the factory name.
     * @param name  the factory name
     */
    public void setFactoryName(String name) {
<span class="nc" id="L424">        factoryName = name;</span>
<span class="nc" id="L425">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets whether to cache the hash code.
     * @return the flag
     */
    public boolean isCacheHashCode() {
<span class="nc" id="L433">        return cacheHashCode;</span>
    }

    /**
     * Sets whether to cache the hash code.
     * @param cacheHashCode  the flag
     */
    public void setCacheHashCode(boolean cacheHashCode) {
<span class="nc" id="L441">        this.cacheHashCode = cacheHashCode;</span>
<span class="nc" id="L442">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets whether property change support is needed.
     * @return the flag
     */
    public boolean isPropertyChangeSupport() {
<span class="nc bnc" id="L450" title="All 2 branches missed.">        for (PropertyData prop : properties) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">            if (prop.isBound()) {</span>
<span class="nc" id="L452">                return true;</span>
            }
<span class="nc" id="L454">        }</span>
<span class="nc" id="L455">        return false;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets whether the bean is immutable.
     * @return the flag
     */
    public boolean isImmutable() {
<span class="nc" id="L464">        return immutable;</span>
    }

    /**
     * Gets whether the bean is mutable.
     * @return the flag
     */
    public boolean isMutable() {
<span class="nc bnc" id="L472" title="All 2 branches missed.">        return !immutable;</span>
    }

    /**
     * Sets whether the bean is immutable.
     * @param immutable  the flag
     */
    public void setImmutable(boolean immutable) {
<span class="nc" id="L480">        this.immutable = immutable;</span>
<span class="nc" id="L481">    }</span>

    /**
     * Checks whether the bean can be constructed.
     * @return the flag
     */
    public boolean isConstructable() {
<span class="nc" id="L488">        return constructable;</span>
    }

    /**
     * Sets whether the bean can be constructed.
     * @param constructable  the flag
     */
    public void setConstructable(boolean constructable) {
<span class="nc" id="L496">        this.constructable = constructable;</span>
<span class="nc" id="L497">    }</span>

    /**
     * Gets whether the bean has a manual constructor to use.
     * @return the flag, zero for none, one for builder based, two for argument based
     */
    public int getImmutableConstructor() {
<span class="nc" id="L504">        return immutableConstructor;</span>
    }

    /**
     * Sets whether the bean has a manual constructor to use.
     * @param manualConstructor  the flag
     */
    public void setImmutableConstructor(int manualConstructor) {
<span class="nc" id="L512">        this.immutableConstructor = manualConstructor;</span>
<span class="nc" id="L513">    }</span>

    /**
     * Gets whether the bean has a validator.
     * @return the method name
     */
    public String getImmutableValidator() {
<span class="nc" id="L520">        return immutableValidator;</span>
    }

    /**
     * Sets whether the bean has a validator.
     * @param immutableValidator  the method name
     */
    public void setImmutableValidator(String immutableValidator) {
<span class="nc" id="L528">        this.immutableValidator = immutableValidator;</span>
<span class="nc" id="L529">    }</span>

    /**
     * Gets whether the bean has an apply defaults method.
     * @return the method name
     */
    public String getImmutableDefaults() {
<span class="nc" id="L536">        return immutableDefaults;</span>
    }

    /**
     * Sets whether the bean has an apply defaults method.
     * @param immutableDefaults  the method name
     */
    public void setImmutableDefaults(String immutableDefaults) {
<span class="nc" id="L544">        this.immutableDefaults = immutableDefaults;</span>
<span class="nc" id="L545">    }</span>

    /**
     * Gets whether the bean has a pre-build method.
     * @return the method name
     */
    public String getImmutablePreBuild() {
<span class="nc" id="L552">        return immutablePreBuild;</span>
    }

    /**
     * Sets whether the bean has a pre-build method.
     * @param immutablePreBuild  the method name
     */
    public void setImmutablePreBuild(String immutablePreBuild) {
<span class="nc" id="L560">        this.immutablePreBuild = immutablePreBuild;</span>
<span class="nc" id="L561">    }</span>

    /**
     * Gets the constructor style to generate.
     * @return the flag, zero for none, one for builder based, two for argument based
     */
    public int getConstructorStyle() {
<span class="nc" id="L568">        return constructorStyle;</span>
    }

    /**
     * Sets the constructor style to generate.
     * @param constructorStyle  the constructor style
     */
    public void setConstructorStyle(int constructorStyle) {
<span class="nc" id="L576">        this.constructorStyle = constructorStyle;</span>
<span class="nc" id="L577">    }</span>

    /**
     * Gets the constructor scope to generate.
     * @return the scope
     */
    public String getConstructorScope() {
<span class="nc" id="L584">        return constructorScope;</span>
    }

    /**
     * Sets the constructor scope to generate.
     * @param constructorScope  the constructor scope
     */
    public void setConstructorScope(String constructorScope) {
<span class="nc" id="L592">        this.constructorScope = constructorScope;</span>
<span class="nc" id="L593">    }</span>

    /**
     * Is the constructor scope valid.
     * @return true if valid
     */
    public boolean isConstructorScopeValid() {
<span class="nc bnc" id="L600" title="All 2 branches missed.">        return &quot;smart&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">                &quot;private&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">                &quot;package&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                &quot;protected&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">                &quot;public&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                &quot;public@ConstructorProperties&quot;.equals(constructorScope);</span>
    }

    /**
     * Gets the effective scope to use in the constructor.
     * @return the scope
     */
    public String getEffectiveConstructorScope() {
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(constructorScope)) {</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">            return isTypeFinal() ? &quot;private &quot; : &quot;protected &quot;;</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">        } else if (&quot;package&quot;.equals(constructorScope)) {</span>
<span class="nc" id="L616">            return &quot;&quot;;</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        } else if (&quot;public@ConstructorProperties&quot;.equals(constructorScope)) {</span>
<span class="nc" id="L618">            return &quot;public &quot;;</span>
        }
<span class="nc" id="L620">        return constructorScope + &quot; &quot;;</span>
    }

    /**
     * Checks if the scope indicates the need for the ConstructorProperties annotation.
     * @return true if the annotation is needed
     */
    public boolean isConstructorPropertiesAnnotation() {
<span class="nc" id="L628">        return &quot;public@ConstructorProperties&quot;.equals(constructorScope);</span>
    }

    /**
     * Checks whether the bean is serializable.
     * @return the flag
     */
    public boolean isSerializable() {
<span class="nc" id="L636">        return serializable;</span>
    }

    /**
     * Sets whether the bean is serializable.
     * @param serializable  the flag
     */
    public void setSerializable(boolean serializable) {
<span class="nc" id="L644">        this.serializable = serializable;</span>
<span class="nc" id="L645">    }</span>

    /**
     * Checks whether the bean has a manual serialization id.
     * @return the flag
     */
    public boolean isManualSerializationId() {
<span class="nc" id="L652">        return manualSerVersionId;</span>
    }

    /**
     * Sets whether the bean has a manual serialization id.
     * @param manualSerVersionId  the flag
     */
    public void setManualSerializationId(boolean manualSerVersionId) {
<span class="nc" id="L660">        this.manualSerVersionId = manualSerVersionId;</span>
<span class="nc" id="L661">    }</span>

    /**
     * Checks if the clone is manual.
     * @return true if manual
     */
    public boolean isManualClone() {
<span class="nc" id="L668">        return manualClone;</span>
    }

    /**
     * Sets if the clone is manual.
     * @param manualClone  true if manual
     */
    public void setManualClone(boolean manualClone) {
<span class="nc" id="L676">        this.manualClone = manualClone;</span>
<span class="nc" id="L677">    }</span>

    /**
     * Checks if the equals/hashCode is manual.
     * @return true if manual
     */
    public boolean isManualEqualsHashCode() {
<span class="nc" id="L684">        return manualEqualsHashCode;</span>
    }

    /**
     * Sets if the equals/hashCode is manual.
     * @param manualEqualsHashCode  true if manual
     */
    public void setManualEqualsHashCode(boolean manualEqualsHashCode) {
<span class="nc" id="L692">        this.manualEqualsHashCode = manualEqualsHashCode;</span>
<span class="nc" id="L693">    }</span>

    /**
     * Checks if the toString is manual.
     * @return true if manual
     */
    public boolean isManualToStringCode() {
<span class="nc" id="L700">        return manualToStringCode;</span>
    }

    /**
     * Sets if the toString is manual.
     * @param manualToStringCode  true if manual
     */
    public void setManualToStringCode(boolean manualToStringCode) {
<span class="nc" id="L708">        this.manualToStringCode = manualToStringCode;</span>
<span class="nc" id="L709">    }</span>

    /**
     * Gets the clone style.
     * @return the clone style
     */
    public String getCloneStyle() {
<span class="nc" id="L716">        return cloneStyle;</span>
    }

    /**
     * Sets the clone style.
     * @param cloneStyle  the clone style
     */
    public void setCloneStyle(String cloneStyle) {
<span class="nc" id="L724">        this.cloneStyle = cloneStyle;</span>
<span class="nc" id="L725">    }</span>

    /**
     * Is the clone style valid.
     * @return true if valid
     */
    public boolean isCloneStyleValid() {
<span class="nc bnc" id="L732" title="All 2 branches missed.">        return &quot;smart&quot;.equals(cloneStyle) ||</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                &quot;omit&quot;.equals(cloneStyle) ||</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">                &quot;generate&quot;.equals(cloneStyle);</span>
    }

    /**
     * Is the clone method to be skiped.
     * @return true to generate
     */
    public boolean isSkipCloneGeneration() {
<span class="nc bnc" id="L742" title="All 6 branches missed.">        return (&quot;smart&quot;.equals(cloneStyle) &amp;&amp; isImmutable()) || &quot;omit&quot;.equals(cloneStyle);</span>
    }

    /**
     * Sets the bean type.
     * @param parts  the type to set
     */
    public void setTypeParts(String[] parts) {
<span class="nc bnc" id="L750" title="All 2 branches missed.">        this.typeFinal = parts[0] != null;</span>
<span class="nc" id="L751">        this.typeScope = parts[1];</span>
<span class="nc" id="L752">        this.typeFull = parts[2];</span>
<span class="nc" id="L753">        this.typeRaw = parts[3];</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (parts[8] != null) {</span>
<span class="nc" id="L755">            this.typeGenericName = new String[] {parts[4], parts[6], parts[8]};</span>
<span class="nc" id="L756">            this.typeGenericExtends = new String[3];</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            this.typeGenericExtends[0] = parts[5] != null ? parts[5] : &quot;&quot;;</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">            this.typeGenericExtends[1] = parts[7] != null ? parts[7] : &quot;&quot;;</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">            this.typeGenericExtends[2] = parts[9] != null ? parts[9] : &quot;&quot;;</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">        } else if (parts[6] != null) {</span>
<span class="nc" id="L761">            this.typeGenericName = new String[] {parts[4], parts[6]};</span>
<span class="nc" id="L762">            this.typeGenericExtends = new String[2];</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">            this.typeGenericExtends[0] = parts[5] != null ? parts[5] : &quot;&quot;;</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">            this.typeGenericExtends[1] = parts[7] != null ? parts[7] : &quot;&quot;;</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">        } else if (parts[4] != null) {</span>
<span class="nc" id="L766">            this.typeGenericName = new String[] {parts[4]};</span>
<span class="nc" id="L767">            this.typeGenericExtends = new String[1];</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">            this.typeGenericExtends[0] = parts[5] != null ? parts[5] : &quot;&quot;;</span>
        } else {
<span class="nc" id="L770">            this.typeGenericName = new String[0];</span>
<span class="nc" id="L771">            this.typeGenericExtends = new String[0];</span>
        }
<span class="nc" id="L773">    }</span>

    /**
     * Sets the bean superclass type.
     * @param parts  the superclass to set
     */
    public void setSuperTypeParts(String[] parts) {
<span class="nc bnc" id="L780" title="All 2 branches missed.">        if (parts.length == 1) {</span>
<span class="nc" id="L781">            this.root = true;</span>
<span class="nc" id="L782">            this.immutable = &quot;ImmutableBean&quot;.equals(parts[0]);</span>
<span class="nc" id="L783">            this.superTypeFull = &quot;&quot;;</span>
<span class="nc" id="L784">            this.superTypeRaw = &quot;&quot;;</span>
<span class="nc" id="L785">            this.superTypeGeneric = &quot;&quot;;</span>
        } else {
<span class="nc" id="L787">            this.root = &quot;DirectBean&quot;.equals(parts[0]);</span>
<span class="nc" id="L788">            this.immutable = false;</span>
<span class="nc" id="L789">            this.superTypeFull = parts[0];</span>
<span class="nc" id="L790">            this.superTypeRaw = parts[1];</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">            if (parts[4] != null) {</span>
<span class="nc" id="L792">                this.superTypeGeneric = parts[2] + &quot;, &quot; + parts[3] + &quot;, &quot; + parts[4];</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">            } else if (parts[3] != null) {</span>
<span class="nc" id="L794">                this.superTypeGeneric = parts[2] + &quot;, &quot; + parts[3];</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">            } else if (parts[2] != null) {</span>
<span class="nc" id="L796">                this.superTypeGeneric = parts[2];</span>
            } else {
<span class="nc" id="L798">                this.superTypeGeneric = &quot;&quot;;</span>
            }
        }
<span class="nc" id="L801">    }</span>

    /**
     * Gets the modifiable list of properties.
     * @return the properties, not null
     */
    public List&lt;PropertyData&gt; getProperties() {
<span class="nc" id="L808">        return properties;</span>
    }

    /**
     * Checks if the type is final.
     * @return true if manual
     */
    public boolean isTypeFinal() {
<span class="nc" id="L816">        return typeFinal;</span>
    }

    /**
     * Sets if the type is final.
     * @param typeFinal  true if final, false if subclassable
     */
    public void setTypeFinal(boolean typeFinal) {
<span class="nc" id="L824">        this.typeFinal = typeFinal;</span>
<span class="nc" id="L825">    }</span>

    /**
     * Gets the scope of the type.
     * @return true if manual
     */
    public String getTypeScope() {
<span class="nc" id="L832">        return typeScope;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this bean is a superclass.
     * @return true if this is a subclass of another bean
     */
    public boolean isSubClass() {
<span class="nc bnc" id="L841" title="All 2 branches missed.">        return !root;</span>
    }

    /**
     * Checks if this bean is the root class in a hierarchy.
     * @return true if this is the root class with no bean superclasses
     */
    public boolean isRootClass() {
<span class="nc" id="L849">        return root;</span>
    }

    /**
     * Checks if this bean directly extends {@code DirectBean}.
     * @return true if this extends DirectBean
     */
    public boolean isExtendsDirectBean() {
<span class="nc" id="L857">        return &quot;DirectBean&quot;.equals(superTypeFull);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if the bean is parameterised with generics.
     * @return true if generified
     */
    public boolean isTypeGeneric() {
<span class="nc bnc" id="L866" title="All 2 branches missed.">        return typeGenericName.length &gt; 0;</span>
    }

    /**
     * Gets the number of generic type parameters.
     * @return zero if no type parameters, one or two if it has type parameters
     */
    public int getTypeGenericCount() {
<span class="nc" id="L874">        return typeGenericName.length;</span>
    }

    /**
     * Gets the bean type, such as '{@code Foo&lt;T extends Bar&gt;}'.
     * @return the type
     */
    public String getType() {
<span class="nc" id="L882">        return typeFull;</span>
    }

    /**
     * Gets the parameterisation of the bean including extends clause, such as '{@code &lt;T extends Bar&gt;}'.
     * @param includeBrackets  whether to include the brackets
     * @return the generic type, or a blank string if not generic, not null
     */
    public String getTypeGeneric(boolean includeBrackets) {
<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (isTypeGeneric() == false) {</span>
<span class="nc" id="L892">            return &quot;&quot;;</span>
        }
<span class="nc" id="L894">        String result = typeGenericName[0] + typeGenericExtends[0];</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">        if (typeGenericExtends.length &gt; 1) {</span>
<span class="nc" id="L896">            result += &quot;, &quot; + typeGenericName[1] + typeGenericExtends[1];</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">            if (typeGenericExtends.length &gt; 2) {</span>
<span class="nc" id="L898">                result += &quot;, &quot; + typeGenericName[2] + typeGenericExtends[2];</span>
            }
        }
<span class="nc bnc" id="L901" title="All 4 branches missed.">        return includeBrackets &amp;&amp; result.length() &gt; 0 ? '&lt;' + result + '&gt;' : result;</span>
    }

    /**
     * Gets the name of the parameterisation of the bean, such as '{@code &lt;T, U&gt;}'.
     * @param includeBrackets  whether to include the brackets
     * @return the generic type name, or a blank string if not generic, not null
     */
    public String getTypeGenericName(boolean includeBrackets) {
<span class="nc bnc" id="L910" title="All 2 branches missed.">        if (isTypeGeneric() == false) {</span>
<span class="nc" id="L911">            return &quot;&quot;;</span>
        }
<span class="nc" id="L913">        String result = typeGenericName[0];</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">        if (typeGenericExtends.length &gt; 1) {</span>
<span class="nc" id="L915">            result += &quot;, &quot; + typeGenericName[1];</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">            if (typeGenericExtends.length &gt; 2) {</span>
<span class="nc" id="L917">                result += &quot;, &quot; + typeGenericName[2];</span>
            }
        }
<span class="nc bnc" id="L920" title="All 4 branches missed.">        return includeBrackets &amp;&amp; result.length() &gt; 0 ? '&lt;' + result + '&gt;' : result;</span>
    }

    /**
     * Gets the diamond operator if generic.
     * @return the generic type name, or a blank string if not generic, not null
     */
    public String getTypeGenericDiamond() {
<span class="nc bnc" id="L928" title="All 2 branches missed.">        return isTypeGeneric() ? &quot;&lt;&gt;&quot; : &quot;&quot;;</span>
    }

    /**
     * Gets the type with the diamond operator if generic.
     * @return the type name, with generic diamond if necessary, not null
     */
    public String getTypeWithDiamond() {
<span class="nc bnc" id="L936" title="All 2 branches missed.">        return isTypeGeneric() ? getTypeRaw() + &quot;&lt;&gt;&quot; : getTypeRaw();</span>
    }

    /**
     * Gets the name of the parameterisation of the bean, such as '{@code &lt;T&gt;}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @param includeBrackets  whether to include brackets
     * @return the generic type name, not null
     */
    public String getTypeGenericName(int typeParamIndex, boolean includeBrackets) {
<span class="nc" id="L946">        String result = typeGenericName[typeParamIndex];</span>
<span class="nc bnc" id="L947" title="All 4 branches missed.">        return includeBrackets &amp;&amp; result.length() &gt; 0 ? '&lt;' + result + '&gt;' : result;</span>
    }

    /**
     * Gets the extends clause of the parameterisation of the bean, such as '{@code  extends Foo}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeGenericErased(int typeParamIndex) {
<span class="nc" id="L956">        String extend = typeGenericExtends[typeParamIndex];</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">        return extend.startsWith(&quot; extends &quot;) ? extend.substring(9) : &quot;Object&quot;;</span>
    }

    /**
     * Gets the extends clause of the parameterisation of the bean, such as '{@code  extends Foo}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeGenericExtends(int typeParamIndex) {
<span class="nc" id="L966">        return typeGenericExtends[typeParamIndex];</span>
    }

    /**
     * Gets the extends clause of the parameterisation of the bean, such as '{@code  extends Foo}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @param typeParamNames  the type parameter names
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeGenericExtends(int typeParamIndex, String[] typeParamNames) {
<span class="nc" id="L976">        String genericClause = typeGenericExtends[typeParamIndex];</span>
<span class="nc" id="L977">        genericClause = genericClause.replace(&quot;&lt;&quot; + typeGenericName[typeParamIndex] + &quot;&gt;&quot;, &quot;&lt;&quot; + typeParamNames[typeParamIndex] + &quot;&gt;&quot;);</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">        for (int i = 0; i &lt; typeGenericName.length; i++) {</span>
<span class="nc" id="L979">            genericClause = genericClause.replace(&quot;&lt;&quot; + typeGenericName[i] + &quot;&gt;&quot;, &quot;&lt;&quot; + typeParamNames[i] + &quot;&gt;&quot;);</span>
<span class="nc" id="L980">            genericClause = genericClause.replace(&quot; extends &quot; + typeGenericName[i] + &quot;&gt;&quot;, &quot; extends &quot; + typeParamNames[i] + &quot;&gt;&quot;);</span>
<span class="nc" id="L981">            genericClause = genericClause.replace(&quot; super &quot; + typeGenericName[i] + &quot;&gt;&quot;, &quot; super &quot; + typeParamNames[i] + &quot;&gt;&quot;);</span>
        }
<span class="nc" id="L983">        return genericClause;</span>
    }

    /**
     * Gets the full type of the bean with simple parameterization, such as '{@code Foo&lt;T&gt;}'.
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeNoExtends() {
<span class="nc" id="L991">        return typeRaw + getTypeGenericName(true);</span>
    }

    /**
     * Gets the raw type of the bean without generics, such as '{@code Foo}'.
     * @return the raw type, not null
     */
    public String getTypeRaw() {
<span class="nc" id="L999">        return typeRaw;</span>
    }

    /**
     * Gets the full type of the bean with wildcarded parameterization, such as '{@code Foo&lt;?&gt;}'.
     * @return the wildcarded type, not null
     */
    public String getTypeWildcard() {
<span class="nc bnc" id="L1007" title="All 2 branches missed.">        if (isTypeGeneric() == false) {</span>
<span class="nc" id="L1008">            return typeRaw;</span>
        }
<span class="nc" id="L1010">        String result = &quot;?&quot;;</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">        if (typeGenericExtends.length &gt; 1) {</span>
<span class="nc" id="L1012">            result += &quot;, ?&quot;;</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">            if (typeGenericExtends.length &gt; 2) {</span>
<span class="nc" id="L1014">                result += &quot;, ?&quot;;</span>
            }
        }
<span class="nc" id="L1017">        return typeRaw + '&lt;' + result + '&gt;';</span>
    }

    /**
     * Checks if the type specified is one of the bean's type parameters.
     * @param type  the type
     * @return true if a type parameter of this bean
     */
    public boolean isTypeGenerifiedBy(String type) {
<span class="nc bnc" id="L1026" title="All 4 branches missed.">        if (typeGenericName.length &gt; 2 &amp;&amp; typeGenericName[2].equals(type)) {</span>
<span class="nc" id="L1027">            return true;</span>
        }
<span class="nc bnc" id="L1029" title="All 4 branches missed.">        if (typeGenericName.length &gt; 1 &amp;&amp; typeGenericName[1].equals(type)) {</span>
<span class="nc" id="L1030">            return true;</span>
        }
<span class="nc bnc" id="L1032" title="All 4 branches missed.">        if (typeGenericName.length &gt; 0 &amp;&amp; typeGenericName[0].equals(type)) {</span>
<span class="nc" id="L1033">            return true;</span>
        }
<span class="nc" id="L1035">        return false;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if the super bean is parameterised with generics.
     * @return true if generified
     */
    public boolean isSuperTypeGeneric() {
<span class="nc bnc" id="L1044" title="All 2 branches missed.">        return superTypeGeneric.length() &gt; 0;</span>
    }

    /**
     * Gets the bean superclass type.
     * @return the superclass
     */
    public String getSuperType() {
<span class="nc" id="L1052">        return superTypeFull;</span>
    }

    /**
     * Gets the parameterisation of the super bean.
     * @param includeBrackets  whether to include the brackets
     * @return the generic type, or a blank string if not generic, not null
     */
    public String getSuperTypeGeneric(boolean includeBrackets) {
<span class="nc bnc" id="L1061" title="All 4 branches missed.">        return includeBrackets &amp;&amp; superTypeGeneric.length() &gt; 0 ? '&lt;' + superTypeGeneric + '&gt;' : superTypeGeneric;</span>
    }

    /**
     * Gets the raw type of the super bean without generics.
     * @return the raw type, not null
     */
    public String getSuperTypeRaw() {
<span class="nc" id="L1069">        return superTypeRaw;</span>
    }

    /**
     * Checks if any property is validated.
     * @return true if validated
     */
    public boolean isValidated() {
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        for (PropertyData property : properties) {</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">            if (property.isValidated()) {</span>
<span class="nc" id="L1079">                return true;</span>
            }
<span class="nc" id="L1081">        }</span>
<span class="nc" id="L1082">        return false;</span>
    }

    /**
     * Gets the scope of nested Meta and Builder classes.
     * @return the scope, not null
     */
    public String getNestedClassConstructorScope() {
<span class="nc bnc" id="L1090" title="All 2 branches missed.">        return (isTypeFinal() ? &quot;private&quot; : &quot;protected&quot;);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>