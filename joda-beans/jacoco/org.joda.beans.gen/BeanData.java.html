<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanData.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda-Beans</a> &gt; <a href="index.source.html" class="el_package">org.joda.beans.gen</a> &gt; <span class="el_source">BeanData.java</span></div><h1>BeanData.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-present Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.beans.gen;

import java.util.ArrayList;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * A bean that can be generated.
 */
class BeanData {

    /** The list of current imports. */
<span class="nc" id="L29">    private final SortedSet&lt;String&gt; currentImports = new TreeSet&lt;&gt;();</span>
    /** The list of new imports. */
<span class="nc" id="L31">    private final SortedSet&lt;String&gt; newImports = new TreeSet&lt;&gt;();</span>
    /** The last import line. */
    private int lastImportLine;
    /** The bean style. */
    private String beanStyle;
    /** The bean meta scope. */
    private String beanMetaScope;
    /** The bean builder scope. */
    private String beanBuilderScope;
    /** The factory method name. */
    private String factoryName;
    /** Whether to cache the hash code. */
    private boolean cacheHashCode;
    /** Whether the class is immutable. */
    private boolean immutable;
    /** Whether the class can be constructed. */
    private boolean constructable;
    /** Whether the class has a manual constructor for immutable beans. */
    private int immutableConstructor;
    /** The method name of the immutable validator. */
    private String immutableValidator;
    /** The method name of the immutable defaults. */
    private String immutableDefaults;
    /** The method name of the immutable pre-build. */
    private String immutablePreBuild;
    /** The style of constructor to generate. */
    private int constructorStyle;
    /** The generated constructor scope. */
    private String constructorScope;
    /** The full type of the bean class. */
    private String typeFull;
    /** The simple name of the bean class. */
    private String typeRaw;
    /** The name clause of the generic. */
    private String[] typeGenericName;
    /** The extends clause of the generic. */
    private String[] typeGenericExtends;
    /** Whether the type is final with no subclasses. */
    private boolean typeFinal;
    /** The scope of the type. */
    private String typeScope;
    /** Whether the type is a root with no bean super-classes. */
    private boolean root;
    /** The full name of the bean superclass. */
    private String superTypeFull;
    /** The simple name of the bean superclass. */
    private String superTypeRaw;
    /** The generic argument of the bean superclass. */
    private String superTypeGeneric;
    /** The list of properties, in the order they are declared. */
<span class="nc" id="L81">    private List&lt;PropertyData&gt; properties = new ArrayList&lt;&gt;();</span>
    /** The serializable flag. */
    private boolean serializable;
    /** The manual serialization version id flag. */
    private boolean manualSerVersionId;
    /** Does the class have a manual clone. */
    private boolean manualClone;
    /** Does the class have a manual equals or hash code. */
    private boolean manualEqualsHashCode;
    /** Does the class have a manual toString. */
    private boolean manualToStringCode;
    /** The style for Object#clone */
    private String cloneStyle;

    /**
     * Constructor.
     */
<span class="nc" id="L98">    BeanData() {</span>
<span class="nc" id="L99">    }</span>

    /**
     * Gets the current set of imports.
     * @return the imports
     */
    public SortedSet&lt;String&gt; getCurrentImports() {
<span class="nc" id="L106">        return currentImports;</span>
    }

    /**
     * Gets the new imports.
     * @return the imports
     */
    public SortedSet&lt;String&gt; getNewImports() {
<span class="nc" id="L114">        return newImports;</span>
    }

    /**
     * Ensures an import is present.
     * @param cls  the class, not null
     */
    public void ensureImport(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (currentImports.contains(cls.getName()) == false) {</span>
<span class="nc" id="L123">            newImports.add(cls.getName());</span>
        }
<span class="nc" id="L125">    }</span>

    /**
     * Gets the import insert location.
     * @return the insert location
     */
    public int getImportInsertLocation() {
<span class="nc" id="L132">        return lastImportLine;</span>
    }

    /**
     * Sets the import insert location.
     * @param location  the insert location
     */
    public void setImportInsertLocation(int location) {
<span class="nc" id="L140">        lastImportLine = location;</span>
<span class="nc" id="L141">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets the bean style.
     * @return the flag
     */
    public String getBeanStyle() {
<span class="nc" id="L149">        return beanStyle;</span>
    }

    /**
     * Sets the bean style.
     * @param beanStyle  the flag
     */
    public void setBeanStyle(String beanStyle) {
<span class="nc" id="L157">        this.beanStyle = beanStyle;</span>
<span class="nc" id="L158">    }</span>

    /**
     * Resolves the bean style.
     * @param defaultStyle  the default style
     */
    public void resolveBeanStyle(String defaultStyle) {
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(beanStyle)) {</span>
<span class="nc" id="L166">            setBeanStyle(defaultStyle);</span>
        }
<span class="nc" id="L168">    }</span>

    /**
     * Is the bean style indicating that properties should be generated.
     * @return the flag
     */
    public boolean isBeanStyleValid() {
<span class="nc bnc" id="L175" title="All 4 branches missed.">        return &quot;full&quot;.equals(beanStyle) || &quot;smart&quot;.equals(beanStyle) ||</span>
<span class="nc bnc" id="L176" title="All 4 branches missed.">                &quot;minimal&quot;.equals(beanStyle) || &quot;light&quot;.equals(beanStyle);</span>
    }

    /**
     * Is the bean style indicating that no meta and builder should be generated.
     * @return the flag
     */
    public boolean isBeanStyleLight() {
<span class="nc" id="L184">        return &quot;light&quot;.equals(beanStyle);</span>
    }

    /**
     * Is the bean style minimal.
     * @return the flag
     */
    public boolean isBeanStyleMinimal() {
<span class="nc" id="L192">        return &quot;minimal&quot;.equals(beanStyle);</span>
    }

    /**
     * Is the bean style indicating that no meta and builder should be generated.
     * @return the flag
     */
    public boolean isBeanStyleLightOrMinimal() {
<span class="nc bnc" id="L200" title="All 4 branches missed.">        return isBeanStyleLight() || isBeanStyleMinimal();</span>
    }

    /**
     * Is the bean style indicating that properties should be generated.
     * @return the flag
     */
    public boolean isBeanStyleGenerateProperties() {
<span class="nc bnc" id="L208" title="All 6 branches missed.">        return &quot;full&quot;.equals(beanStyle) || (&quot;smart&quot;.equals(beanStyle) &amp;&amp; isImmutable() == false);</span>
    }

    /**
     * Is the bean style indicating that properties should be generated.
     * @return the flag
     */
    public boolean isBeanStyleGenerateMetaProperties() {
<span class="nc bnc" id="L216" title="All 6 branches missed.">        return (&quot;full&quot;.equals(beanStyle) || &quot;smart&quot;.equals(beanStyle)) &amp;&amp; !isMetaScopePrivate();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the bean meta scope.
     * @return the scope
     */
    public String getBeanMetaScope() {
<span class="nc" id="L225">        return beanMetaScope;</span>
    }

    /**
     * Sets the bean meta scope.
     * @param metaScope  the scope
     */
    public void setBeanMetaScope(String metaScope) {
<span class="nc" id="L233">        this.beanMetaScope = metaScope;</span>
<span class="nc" id="L234">    }</span>

    /**
     * Is the meta scope valid.
     * @return the flag
     */
    public boolean isBeanMetaScopeValid() {
<span class="nc bnc" id="L241" title="All 2 branches missed.">        return &quot;smart&quot;.equals(beanMetaScope) ||</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                &quot;private&quot;.equals(beanMetaScope) ||</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">                &quot;package&quot;.equals(beanMetaScope) ||</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                &quot;public&quot;.equals(beanMetaScope);</span>
    }

    /**
     * Gets the effective scope to use in the meta.
     * @return the scope
     */
    public String getEffectiveMetaScope() {
<span class="nc" id="L252">        String scope = beanMetaScope;</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(scope)) {</span>
<span class="nc" id="L254">            scope = typeScope;</span>
        }
<span class="nc bnc" id="L256" title="All 2 branches missed.">        return &quot;package&quot;.equals(scope) ? &quot;&quot; : scope + &quot; &quot;;</span>
    }

    /**
     * Checks the meta-bean scope.
     * @return the scope
     */
    public boolean isMetaScopePrivate() {
<span class="nc bnc" id="L264" title="All 4 branches missed.">        return &quot;private&quot;.equals(beanMetaScope) || isBeanStyleLight();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the bean builder scope.
     * @return the scope
     */
    public String getBeanBuilderScope() {
<span class="nc" id="L273">        return beanBuilderScope;</span>
    }

    /**
     * Sets the bean builder scope.
     * @param builderScope  the scope
     */
    public void setBeanBuilderScope(String builderScope) {
<span class="nc" id="L281">        this.beanBuilderScope = builderScope;</span>
<span class="nc" id="L282">    }</span>

    /**
     * Is the builder scope valid.
     * @return the flag
     */
    public boolean isBeanBuilderScopeValid() {
<span class="nc bnc" id="L289" title="All 2 branches missed.">        return &quot;smart&quot;.equals(beanBuilderScope) ||</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                &quot;private&quot;.equals(beanBuilderScope) ||</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                &quot;package&quot;.equals(beanBuilderScope) ||</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                &quot;public&quot;.equals(beanBuilderScope);</span>
    }

    /**
     * Gets the effective scope to use in the builder.
     * @return the scope
     */
    public String getEffectiveBuilderScope() {
<span class="nc" id="L300">        String scope = beanBuilderScope;</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(scope)) {</span>
<span class="nc" id="L302">            scope = typeScope;</span>
        }
<span class="nc bnc" id="L304" title="All 2 branches missed.">        return &quot;package&quot;.equals(scope) ? &quot;&quot; : scope + &quot; &quot;;</span>
    }

    /**
     * Is the effective scope to use in the builder public.
     * @return the scope
     */
    public boolean isEffectiveBuilderScopeVisible() {
<span class="nc bnc" id="L312" title="All 6 branches missed.">        return (&quot;smart&quot;.equals(beanBuilderScope) || &quot;public&quot;.equals(beanBuilderScope) || &quot;package&quot;.equals(beanBuilderScope)) &amp;&amp;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">                !isBeanStyleLight();</span>
    }

    /**
     * Is the scope to use in the builder public.
     * @return the scope
     */
    public boolean isBuilderScopeVisible() {
<span class="nc bnc" id="L321" title="All 4 branches missed.">        return &quot;public&quot;.equals(beanBuilderScope) || &quot;package&quot;.equals(beanBuilderScope);</span>
    }

    /**
     * Is the builder generated
     * @return true if generated
     */
    public boolean isBuilderGenerated() {
<span class="nc bnc" id="L329" title="All 8 branches missed.">        return (isImmutable() &amp;&amp; isEffectiveBuilderScopeVisible()) || (isMutable() &amp;&amp; isBuilderScopeVisible());</span>
    }

    /**
     * Is the builder generated
     * @return true if generated
     */
    public boolean isSkipBuilderGeneration() {
<span class="nc bnc" id="L337" title="All 6 branches missed.">        return (isMutable() &amp;&amp; isBuilderScopeVisible() == false) || isBeanStyleLight();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the factory name.
     * @return the factory name
     */
    public boolean isFactoryRequired() {
<span class="nc bnc" id="L346" title="All 2 branches missed.">        return factoryName.length() &gt; 0;</span>
    }

    /**
     * Gets the factory name.
     * @return the factory name
     */
    public String getFactoryName() {
<span class="nc" id="L354">        return factoryName;</span>
    }

    /**
     * Sets the factory name.
     * @param name  the factory name
     */
    public void setFactoryName(String name) {
<span class="nc" id="L362">        factoryName = name;</span>
<span class="nc" id="L363">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets whether to cache the hash code.
     * @return the flag
     */
    public boolean isCacheHashCode() {
<span class="nc" id="L371">        return cacheHashCode;</span>
    }

    /**
     * Sets whether to cache the hash code.
     * @param cacheHashCode  the flag
     */
    public void setCacheHashCode(boolean cacheHashCode) {
<span class="nc" id="L379">        this.cacheHashCode = cacheHashCode;</span>
<span class="nc" id="L380">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets whether property change support is needed.
     * @return the flag
     */
    public boolean isPropertyChangeSupport() {
<span class="nc bnc" id="L388" title="All 2 branches missed.">        for (PropertyData prop : properties) {</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">            if (prop.isBound()) {</span>
<span class="nc" id="L390">                return true;</span>
            }
<span class="nc" id="L392">        }</span>
<span class="nc" id="L393">        return false;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets whether the bean is immutable.
     * @return the flag
     */
    public boolean isImmutable() {
<span class="nc" id="L402">        return immutable;</span>
    }

    /**
     * Gets whether the bean is mutable.
     * @return the flag
     */
    public boolean isMutable() {
<span class="nc bnc" id="L410" title="All 2 branches missed.">        return !immutable;</span>
    }

    /**
     * Sets whether the bean is immutable.
     * @param immutable  the flag
     */
    public void setImmutable(boolean immutable) {
<span class="nc" id="L418">        this.immutable = immutable;</span>
<span class="nc" id="L419">    }</span>

    /**
     * Checks whether the bean can be constructed.
     * @return the flag
     */
    public boolean isConstructable() {
<span class="nc" id="L426">        return constructable;</span>
    }

    /**
     * Sets whether the bean can be constructed.
     * @param constructable  the flag
     */
    public void setConstructable(boolean constructable) {
<span class="nc" id="L434">        this.constructable = constructable;</span>
<span class="nc" id="L435">    }</span>

    /**
     * Gets whether the bean has a manual constructor to use.
     * @return the flag, zero for none, one for builder based, two for argument based
     */
    public int getImmutableConstructor() {
<span class="nc" id="L442">        return immutableConstructor;</span>
    }

    /**
     * Sets whether the bean has a manual constructor to use.
     * @param manualConstructor  the flag
     */
    public void setImmutableConstructor(int manualConstructor) {
<span class="nc" id="L450">        this.immutableConstructor = manualConstructor;</span>
<span class="nc" id="L451">    }</span>

    /**
     * Gets whether the bean has a validator.
     * @return the method name
     */
    public String getImmutableValidator() {
<span class="nc" id="L458">        return immutableValidator;</span>
    }

    /**
     * Sets whether the bean has a validator.
     * @param immutableValidator  the method name
     */
    public void setImmutableValidator(String immutableValidator) {
<span class="nc" id="L466">        this.immutableValidator = immutableValidator;</span>
<span class="nc" id="L467">    }</span>

    /**
     * Gets whether the bean has an apply defaults method.
     * @return the method name
     */
    public String getImmutableDefaults() {
<span class="nc" id="L474">        return immutableDefaults;</span>
    }

    /**
     * Sets whether the bean has an apply defaults method.
     * @param immutableDefaults  the method name
     */
    public void setImmutableDefaults(String immutableDefaults) {
<span class="nc" id="L482">        this.immutableDefaults = immutableDefaults;</span>
<span class="nc" id="L483">    }</span>

    /**
     * Gets whether the bean has a pre-build method.
     * @return the method name
     */
    public String getImmutablePreBuild() {
<span class="nc" id="L490">        return immutablePreBuild;</span>
    }

    /**
     * Sets whether the bean has a pre-build method.
     * @param immutablePreBuild  the method name
     */
    public void setImmutablePreBuild(String immutablePreBuild) {
<span class="nc" id="L498">        this.immutablePreBuild = immutablePreBuild;</span>
<span class="nc" id="L499">    }</span>

    /**
     * Gets the constructor style to generate.
     * @return the flag, zero for none, one for builder based, two for argument based
     */
    public int getConstructorStyle() {
<span class="nc" id="L506">        return constructorStyle;</span>
    }

    /**
     * Sets the constructor style to generate.
     * @param constructorStyle  the constructor style
     */
    public void setConstructorStyle(int constructorStyle) {
<span class="nc" id="L514">        this.constructorStyle = constructorStyle;</span>
<span class="nc" id="L515">    }</span>

    /**
     * Gets the constructor scope to generate.
     * @return the scope
     */
    public String getConstructorScope() {
<span class="nc" id="L522">        return constructorScope;</span>
    }

    /**
     * Sets the constructor scope to generate.
     * @param constructorScope  the constructor scope
     */
    public void setConstructorScope(String constructorScope) {
<span class="nc" id="L530">        this.constructorScope = constructorScope;</span>
<span class="nc" id="L531">    }</span>

    /**
     * Is the constructor scope valid.
     * @return true if valid
     */
    public boolean isConstructorScopeValid() {
<span class="nc bnc" id="L538" title="All 2 branches missed.">        return &quot;smart&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                &quot;private&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">                &quot;package&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                &quot;protected&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">                &quot;public&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">                &quot;public@ConstructorProperties&quot;.equals(constructorScope);</span>
    }

    /**
     * Gets the effective scope to use in the constructor.
     * @return the scope
     */
    public String getEffectiveConstructorScope() {
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(constructorScope)) {</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            return isTypeFinal() ? &quot;private &quot; : &quot;protected &quot;;</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        } else if (&quot;package&quot;.equals(constructorScope)) {</span>
<span class="nc" id="L554">            return &quot;&quot;;</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">        } else if (&quot;public@ConstructorProperties&quot;.equals(constructorScope)) {</span>
<span class="nc" id="L556">            return &quot;public &quot;;</span>
        }
<span class="nc" id="L558">        return constructorScope + &quot; &quot;;</span>
    }

    /**
     * Checks if the scope indicates the need for the ConstructorProperties annotation.
     * @return true if the annotation is needed
     */
    public boolean isConstructorPropertiesAnnotation() {
<span class="nc" id="L566">        return &quot;public@ConstructorProperties&quot;.equals(constructorScope);</span>
    }

    /**
     * Checks whether the bean is serializable.
     * @return the flag
     */
    public boolean isSerializable() {
<span class="nc" id="L574">        return serializable;</span>
    }

    /**
     * Sets whether the bean is serializable.
     * @param serializable  the flag
     */
    public void setSerializable(boolean serializable) {
<span class="nc" id="L582">        this.serializable = serializable;</span>
<span class="nc" id="L583">    }</span>

    /**
     * Checks whether the bean has a manual serialization id.
     * @return the flag
     */
    public boolean isManualSerializationId() {
<span class="nc" id="L590">        return manualSerVersionId;</span>
    }

    /**
     * Sets whether the bean has a manual serialization id.
     * @param manualSerVersionId  the flag
     */
    public void setManualSerializationId(boolean manualSerVersionId) {
<span class="nc" id="L598">        this.manualSerVersionId = manualSerVersionId;</span>
<span class="nc" id="L599">    }</span>

    /**
     * Checks if the clone is manual.
     * @return true if manual
     */
    public boolean isManualClone() {
<span class="nc" id="L606">        return manualClone;</span>
    }

    /**
     * Sets if the clone is manual.
     * @param manualClone  true if manual
     */
    public void setManualClone(boolean manualClone) {
<span class="nc" id="L614">        this.manualClone = manualClone;</span>
<span class="nc" id="L615">    }</span>

    /**
     * Checks if the equals/hashCode is manual.
     * @return true if manual
     */
    public boolean isManualEqualsHashCode() {
<span class="nc" id="L622">        return manualEqualsHashCode;</span>
    }

    /**
     * Sets if the equals/hashCode is manual.
     * @param manualEqualsHashCode  true if manual
     */
    public void setManualEqualsHashCode(boolean manualEqualsHashCode) {
<span class="nc" id="L630">        this.manualEqualsHashCode = manualEqualsHashCode;</span>
<span class="nc" id="L631">    }</span>

    /**
     * Checks if the toString is manual.
     * @return true if manual
     */
    public boolean isManualToStringCode() {
<span class="nc" id="L638">        return manualToStringCode;</span>
    }

    /**
     * Sets if the toString is manual.
     * @param manualToStringCode  true if manual
     */
    public void setManualToStringCode(boolean manualToStringCode) {
<span class="nc" id="L646">        this.manualToStringCode = manualToStringCode;</span>
<span class="nc" id="L647">    }</span>

    /**
     * Gets the clone style.
     * @return the clone style
     */
    public String getCloneStyle() {
<span class="nc" id="L654">        return cloneStyle;</span>
    }

    /**
     * Sets the clone style.
     * @param cloneStyle  the clone style
     */
    public void setCloneStyle(String cloneStyle) {
<span class="nc" id="L662">        this.cloneStyle = cloneStyle;</span>
<span class="nc" id="L663">    }</span>

    /**
     * Is the clone style valid.
     * @return true if valid
     */
    public boolean isCloneStyleValid() {
<span class="nc bnc" id="L670" title="All 2 branches missed.">        return &quot;smart&quot;.equals(cloneStyle) ||</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">                &quot;omit&quot;.equals(cloneStyle) ||</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">                &quot;generate&quot;.equals(cloneStyle);</span>
    }

    /**
     * Is the clone method to be skiped.
     * @return true to generate
     */
    public boolean isSkipCloneGeneration() {
<span class="nc bnc" id="L680" title="All 6 branches missed.">        return (&quot;smart&quot;.equals(cloneStyle) &amp;&amp; isImmutable()) || &quot;omit&quot;.equals(cloneStyle);</span>
    }

    /**
     * Sets the bean type.
     * @param parts  the type to set
     */
    public void setTypeParts(String[] parts) {
<span class="nc bnc" id="L688" title="All 2 branches missed.">        this.typeFinal = parts[0] != null;</span>
<span class="nc" id="L689">        this.typeScope = parts[1];</span>
<span class="nc" id="L690">        this.typeFull = parts[2];</span>
<span class="nc" id="L691">        this.typeRaw = parts[3];</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        if (parts[8] != null) {</span>
<span class="nc" id="L693">            this.typeGenericName = new String[] {parts[4], parts[6], parts[8]};</span>
<span class="nc" id="L694">            this.typeGenericExtends = new String[3];</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">            this.typeGenericExtends[0] = parts[5] != null ? parts[5] : &quot;&quot;;</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">            this.typeGenericExtends[1] = parts[7] != null ? parts[7] : &quot;&quot;;</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">            this.typeGenericExtends[2] = parts[9] != null ? parts[9] : &quot;&quot;;</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        } else if (parts[6] != null) {</span>
<span class="nc" id="L699">            this.typeGenericName = new String[] {parts[4], parts[6]};</span>
<span class="nc" id="L700">            this.typeGenericExtends = new String[2];</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">            this.typeGenericExtends[0] = parts[5] != null ? parts[5] : &quot;&quot;;</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">            this.typeGenericExtends[1] = parts[7] != null ? parts[7] : &quot;&quot;;</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">        } else if (parts[4] != null) {</span>
<span class="nc" id="L704">            this.typeGenericName = new String[] {parts[4]};</span>
<span class="nc" id="L705">            this.typeGenericExtends = new String[1];</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">            this.typeGenericExtends[0] = parts[5] != null ? parts[5] : &quot;&quot;;</span>
        } else {
<span class="nc" id="L708">            this.typeGenericName = new String[0];</span>
<span class="nc" id="L709">            this.typeGenericExtends = new String[0];</span>
        }
<span class="nc" id="L711">    }</span>

    /**
     * Sets the bean superclass type.
     * @param parts  the superclass to set
     */
    public void setSuperTypeParts(String[] parts) {
<span class="nc bnc" id="L718" title="All 2 branches missed.">        if (parts.length == 1) {</span>
<span class="nc" id="L719">            this.root = true;</span>
<span class="nc" id="L720">            this.immutable = &quot;ImmutableBean&quot;.equals(parts[0]);</span>
<span class="nc" id="L721">            this.superTypeFull = &quot;&quot;;</span>
<span class="nc" id="L722">            this.superTypeRaw = &quot;&quot;;</span>
<span class="nc" id="L723">            this.superTypeGeneric = &quot;&quot;;</span>
        } else {
<span class="nc" id="L725">            this.root = &quot;DirectBean&quot;.equals(parts[0]);</span>
<span class="nc" id="L726">            this.immutable = false;</span>
<span class="nc" id="L727">            this.superTypeFull = parts[0];</span>
<span class="nc" id="L728">            this.superTypeRaw = parts[1];</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">            if (parts[4] != null) {</span>
<span class="nc" id="L730">                this.superTypeGeneric = parts[2] + &quot;, &quot; + parts[3] + &quot;, &quot; + parts[4];</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">            } else if (parts[3] != null) {</span>
<span class="nc" id="L732">                this.superTypeGeneric = parts[2] + &quot;, &quot; + parts[3];</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">            } else if (parts[2] != null) {</span>
<span class="nc" id="L734">                this.superTypeGeneric = parts[2];</span>
            } else {
<span class="nc" id="L736">                this.superTypeGeneric = &quot;&quot;;</span>
            }
        }
<span class="nc" id="L739">    }</span>

    /**
     * Gets the modifiable list of properties.
     * @return the properties, not null
     */
    public List&lt;PropertyData&gt; getProperties() {
<span class="nc" id="L746">        return properties;</span>
    }

    /**
     * Checks if the type is final.
     * @return true if manual
     */
    public boolean isTypeFinal() {
<span class="nc" id="L754">        return typeFinal;</span>
    }

    /**
     * Sets if the type is final.
     * @param typeFinal  true if final, false if subclassable
     */
    public void setTypeFinal(boolean typeFinal) {
<span class="nc" id="L762">        this.typeFinal = typeFinal;</span>
<span class="nc" id="L763">    }</span>

    /**
     * Gets the scope of the type.
     * @return true if manual
     */
    public String getTypeScope() {
<span class="nc" id="L770">        return typeScope;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this bean is a superclass.
     * @return true if this is a subclass of another bean
     */
    public boolean isSubClass() {
<span class="nc bnc" id="L779" title="All 2 branches missed.">        return !root;</span>
    }

    /**
     * Checks if this bean is the root class in a hierarchy.
     * @return true if this is the root class with no bean superclasses
     */
    public boolean isRootClass() {
<span class="nc" id="L787">        return root;</span>
    }

    /**
     * Checks if this bean directly extends {@code DirectBean}.
     * @return true if this extends DirectBean
     */
    public boolean isExtendsDirectBean() {
<span class="nc" id="L795">        return &quot;DirectBean&quot;.equals(superTypeFull);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if the bean is parameterised with generics.
     * @return true if generified
     */
    public boolean isTypeGeneric() {
<span class="nc bnc" id="L804" title="All 2 branches missed.">        return typeGenericName.length &gt; 0;</span>
    }

    /**
     * Gets the number of generic type parameters.
     * @return zero if no type parameters, one or two if it has type parameters
     */
    public int getTypeGenericCount() {
<span class="nc" id="L812">        return typeGenericName.length;</span>
    }

    /**
     * Gets the bean type, such as '{@code Foo&lt;T extends Bar&gt;}'.
     * @return the type
     */
    public String getType() {
<span class="nc" id="L820">        return typeFull;</span>
    }

    /**
     * Gets the parameterisation of the bean including extends clause, such as '{@code &lt;T extends Bar&gt;}'.
     * @param includeBrackets  whether to include the brackets
     * @return the generic type, or a blank string if not generic, not null
     */
    public String getTypeGeneric(boolean includeBrackets) {
<span class="nc bnc" id="L829" title="All 2 branches missed.">        if (isTypeGeneric() == false) {</span>
<span class="nc" id="L830">            return &quot;&quot;;</span>
        }
<span class="nc" id="L832">        String result = typeGenericName[0] + typeGenericExtends[0];</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (typeGenericExtends.length &gt; 1) {</span>
<span class="nc" id="L834">            result += &quot;, &quot; + typeGenericName[1] + typeGenericExtends[1];</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">            if (typeGenericExtends.length &gt; 2) {</span>
<span class="nc" id="L836">                result += &quot;, &quot; + typeGenericName[2] + typeGenericExtends[2];</span>
            }
        }
<span class="nc bnc" id="L839" title="All 4 branches missed.">        return includeBrackets &amp;&amp; result.length() &gt; 0 ? '&lt;' + result + '&gt;' : result;</span>
    }

    /**
     * Gets the name of the parameterisation of the bean, such as '{@code &lt;T, U&gt;}'.
     * @param includeBrackets  whether to include the brackets
     * @return the generic type name, or a blank string if not generic, not null
     */
    public String getTypeGenericName(boolean includeBrackets) {
<span class="nc bnc" id="L848" title="All 2 branches missed.">        if (isTypeGeneric() == false) {</span>
<span class="nc" id="L849">            return &quot;&quot;;</span>
        }
<span class="nc" id="L851">        String result = typeGenericName[0];</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (typeGenericExtends.length &gt; 1) {</span>
<span class="nc" id="L853">            result += &quot;, &quot; + typeGenericName[1];</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">            if (typeGenericExtends.length &gt; 2) {</span>
<span class="nc" id="L855">                result += &quot;, &quot; + typeGenericName[2];</span>
            }
        }
<span class="nc bnc" id="L858" title="All 4 branches missed.">        return includeBrackets &amp;&amp; result.length() &gt; 0 ? '&lt;' + result + '&gt;' : result;</span>
    }

    /**
     * Gets the diamond operator if generic.
     * @return the generic type name, or a blank string if not generic, not null
     */
    public String getTypeGenericDiamond() {
<span class="nc bnc" id="L866" title="All 2 branches missed.">        return isTypeGeneric() ? &quot;&lt;&gt;&quot; : &quot;&quot;;</span>
    }

    /**
     * Gets the type with the diamond operator if generic.
     * @return the type name, with generic diamond if necessary, not null
     */
    public String getTypeWithDiamond() {
<span class="nc bnc" id="L874" title="All 2 branches missed.">        return isTypeGeneric() ? getTypeRaw() + &quot;&lt;&gt;&quot; : getTypeRaw();</span>
    }

    /**
     * Gets the name of the parameterisation of the bean, such as '{@code &lt;T&gt;}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @param includeBrackets  whether to include brackets
     * @return the generic type name, not null
     */
    public String getTypeGenericName(int typeParamIndex, boolean includeBrackets) {
<span class="nc" id="L884">        String result = typeGenericName[typeParamIndex];</span>
<span class="nc bnc" id="L885" title="All 4 branches missed.">        return includeBrackets &amp;&amp; result.length() &gt; 0 ? '&lt;' + result + '&gt;' : result;</span>
    }

    /**
     * Gets the extends clause of the parameterisation of the bean, such as '{@code  extends Foo}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeGenericErased(int typeParamIndex) {
<span class="nc" id="L894">        String extend = typeGenericExtends[typeParamIndex];</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">        return extend.startsWith(&quot; extends &quot;) ? extend.substring(9) : &quot;Object&quot;;</span>
    }

    /**
     * Gets the extends clause of the parameterisation of the bean, such as '{@code  extends Foo}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeGenericExtends(int typeParamIndex) {
<span class="nc" id="L904">        return typeGenericExtends[typeParamIndex];</span>
    }

    /**
     * Gets the extends clause of the parameterisation of the bean, such as '{@code  extends Foo}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @param typeParamNames  the type parameter names
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeGenericExtends(int typeParamIndex, String[] typeParamNames) {
<span class="nc" id="L914">        String genericClause = typeGenericExtends[typeParamIndex];</span>
<span class="nc" id="L915">        genericClause = genericClause.replace(&quot;&lt;&quot; + typeGenericName[typeParamIndex] + &quot;&gt;&quot;, &quot;&lt;&quot; + typeParamNames[typeParamIndex] + &quot;&gt;&quot;);</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">        for (int i = 0; i &lt; typeGenericName.length; i++) {</span>
<span class="nc" id="L917">            genericClause = genericClause.replace(&quot;&lt;&quot; + typeGenericName[i] + &quot;&gt;&quot;, &quot;&lt;&quot; + typeParamNames[i] + &quot;&gt;&quot;);</span>
<span class="nc" id="L918">            genericClause = genericClause.replace(&quot; extends &quot; + typeGenericName[i] + &quot;&gt;&quot;, &quot; extends &quot; + typeParamNames[i] + &quot;&gt;&quot;);</span>
<span class="nc" id="L919">            genericClause = genericClause.replace(&quot; super &quot; + typeGenericName[i] + &quot;&gt;&quot;, &quot; super &quot; + typeParamNames[i] + &quot;&gt;&quot;);</span>
        }
<span class="nc" id="L921">        return genericClause;</span>
    }

    /**
     * Gets the full type of the bean with simple parameterization, such as '{@code Foo&lt;T&gt;}'.
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeNoExtends() {
<span class="nc" id="L929">        return typeRaw + getTypeGenericName(true);</span>
    }

    /**
     * Gets the raw type of the bean without generics, such as '{@code Foo}'.
     * @return the raw type, not null
     */
    public String getTypeRaw() {
<span class="nc" id="L937">        return typeRaw;</span>
    }

    /**
     * Gets the full type of the bean with wildcarded parameterization, such as '{@code Foo&lt;?&gt;}'.
     * @return the wildcarded type, not null
     */
    public String getTypeWildcard() {
<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (isTypeGeneric() == false) {</span>
<span class="nc" id="L946">            return typeRaw;</span>
        }
<span class="nc" id="L948">        String result = &quot;?&quot;;</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">        if (typeGenericExtends.length &gt; 1) {</span>
<span class="nc" id="L950">            result += &quot;, ?&quot;;</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">            if (typeGenericExtends.length &gt; 2) {</span>
<span class="nc" id="L952">                result += &quot;, ?&quot;;</span>
            }
        }
<span class="nc" id="L955">        return typeRaw + '&lt;' + result + '&gt;';</span>
    }

    /**
     * Checks if the type specified is one of the bean's type parameters.
     * @param type  the type
     * @return true if a type parameter of this bean
     */
    public boolean isTypeGenerifiedBy(String type) {
<span class="nc bnc" id="L964" title="All 4 branches missed.">        if (typeGenericName.length &gt; 2 &amp;&amp; typeGenericName[2].equals(type)) {</span>
<span class="nc" id="L965">            return true;</span>
        }
<span class="nc bnc" id="L967" title="All 4 branches missed.">        if (typeGenericName.length &gt; 1 &amp;&amp; typeGenericName[1].equals(type)) {</span>
<span class="nc" id="L968">            return true;</span>
        }
<span class="nc bnc" id="L970" title="All 4 branches missed.">        if (typeGenericName.length &gt; 0 &amp;&amp; typeGenericName[0].equals(type)) {</span>
<span class="nc" id="L971">            return true;</span>
        }
<span class="nc" id="L973">        return false;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if the super bean is parameterised with generics.
     * @return true if generified
     */
    public boolean isSuperTypeGeneric() {
<span class="nc bnc" id="L982" title="All 2 branches missed.">        return superTypeGeneric.length() &gt; 0;</span>
    }

    /**
     * Gets the bean superclass type.
     * @return the superclass
     */
    public String getSuperType() {
<span class="nc" id="L990">        return superTypeFull;</span>
    }

    /**
     * Gets the parameterisation of the super bean.
     * @param includeBrackets  whether to include the brackets
     * @return the generic type, or a blank string if not generic, not null
     */
    public String getSuperTypeGeneric(boolean includeBrackets) {
<span class="nc bnc" id="L999" title="All 4 branches missed.">        return includeBrackets &amp;&amp; superTypeGeneric.length() &gt; 0 ? '&lt;' + superTypeGeneric + '&gt;' : superTypeGeneric;</span>
    }

    /**
     * Gets the raw type of the super bean without generics.
     * @return the raw type, not null
     */
    public String getSuperTypeRaw() {
<span class="nc" id="L1007">        return superTypeRaw;</span>
    }

    /**
     * Checks if any property is validated.
     * @return true if validated
     */
    public boolean isValidated() {
<span class="nc bnc" id="L1015" title="All 2 branches missed.">        for (PropertyData property : properties) {</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">            if (property.isValidated()) {</span>
<span class="nc" id="L1017">                return true;</span>
            }
<span class="nc" id="L1019">        }</span>
<span class="nc" id="L1020">        return false;</span>
    }

    /**
     * Gets the scope of nested Meta and Builder classes.
     * @return the scope, not null
     */
    public String getNestedClassConstructorScope() {
<span class="nc bnc" id="L1028" title="All 2 branches missed.">        return (isTypeFinal() ? &quot;private&quot; : &quot;protected&quot;);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>