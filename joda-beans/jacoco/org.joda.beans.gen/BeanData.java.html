<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanData.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda-Beans</a> &gt; <a href="index.source.html" class="el_package">org.joda.beans.gen</a> &gt; <span class="el_source">BeanData.java</span></div><h1>BeanData.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-present Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.beans.gen;

import java.util.ArrayList;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * A bean that can be generated.
 * 
 * @author Stephen Colebourne
 */
class BeanData {

    /** The list of current imports. */
<span class="nc" id="L31">    private final SortedSet&lt;String&gt; currentImports = new TreeSet&lt;&gt;();</span>
    /** The list of new imports. */
<span class="nc" id="L33">    private final SortedSet&lt;String&gt; newImports = new TreeSet&lt;&gt;();</span>
    /** The last import line. */
    private int lastImportLine;
    /** The bean style. */
    private String beanStyle;
    /** The bean meta scope. */
    private String beanMetaScope;
    /** The bean builder scope. */
    private String beanBuilderScope;
    /** The factory method name. */
    private String factoryName;
    /** Whether to cache the hash code. */
    private boolean cacheHashCode;
    /** Whether the class is immutable. */
    private boolean immutable;
    /** Whether the class can be constructed. */
    private boolean constructable;
    /** Whether the class has a manual constructor for immutable beans. */
    private int immutableConstructor;
    /** The method name of the immutable validator. */
    private String immutableValidator;
    /** The method name of the immutable defaults. */
    private String immutableDefaults;
    /** The method name of the immutable pre-build. */
    private String immutablePreBuild;
    /** The style of constructor to generate. */
    private int constructorStyle;
    /** The generated constructor scope. */
    private String constructorScope;
    /** The full type of the bean class. */
    private String typeFull;
    /** The simple name of the bean class. */
    private String typeRaw;
    /** The name clause of the generic. */
    private String[] typeGenericName;
    /** The extends clause of the generic. */
    private String[] typeGenericExtends;
    /** Whether the type is final with no subclasses. */
    private boolean typeFinal;
    /** The scope of the type. */
    private String typeScope;
    /** Whether the type is a root with no bean super-classes. */
    private boolean root;
    /** The full name of the bean superclass. */
    private String superTypeFull;
    /** The simple name of the bean superclass. */
    private String superTypeRaw;
    /** The generic argument of the bean superclass. */
    private String superTypeGeneric;
    /** The list of properties, in the order they are declared. */
<span class="nc" id="L83">    private List&lt;PropertyData&gt; properties = new ArrayList&lt;&gt;();</span>
    /** The serializable flag. */
    private boolean serializable;
    /** The manual serialization version id flag. */
    private boolean manualSerVersionId;
    /** Does the class have a manual clone. */
    private boolean manualClone;
    /** Does the class have a manual equals or hash code. */
    private boolean manualEqualsHashCode;
    /** Does the class have a manual toString. */
    private boolean manualToStringCode;
    /** The style for Object#clone */
    private String cloneStyle;

    /**
     * Constructor.
     */
<span class="nc" id="L100">    BeanData() {</span>
<span class="nc" id="L101">    }</span>

    /**
     * Gets the current set of imports.
     * @return the imports
     */
    public SortedSet&lt;String&gt; getCurrentImports() {
<span class="nc" id="L108">        return currentImports;</span>
    }

    /**
     * Gets the new imports.
     * @return the imports
     */
    public SortedSet&lt;String&gt; getNewImports() {
<span class="nc" id="L116">        return newImports;</span>
    }

    /**
     * Ensures an import is present.
     * @param cls  the class, not null
     */
    public void ensureImport(Class&lt;?&gt; cls) {
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (currentImports.contains(cls.getName()) == false) {</span>
<span class="nc" id="L125">            newImports.add(cls.getName());</span>
        }
<span class="nc" id="L127">    }</span>

    /**
     * Gets the import insert location.
     * @return the insert location
     */
    public int getImportInsertLocation() {
<span class="nc" id="L134">        return lastImportLine;</span>
    }

    /**
     * Sets the import insert location.
     * @param location  the insert location
     */
    public void setImportInsertLocation(int location) {
<span class="nc" id="L142">        lastImportLine = location;</span>
<span class="nc" id="L143">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets the bean style.
     * @return the flag
     */
    public String getBeanStyle() {
<span class="nc" id="L151">        return beanStyle;</span>
    }

    /**
     * Sets the bean style.
     * @param beanStyle  the flag
     */
    public void setBeanStyle(String beanStyle) {
<span class="nc" id="L159">        this.beanStyle = beanStyle;</span>
<span class="nc" id="L160">    }</span>

    /**
     * Resolves the bean style.
     * @param defaultStyle  the default style
     */
    public void resolveBeanStyle(String defaultStyle) {
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(beanStyle)) {</span>
<span class="nc" id="L168">            setBeanStyle(defaultStyle);</span>
        }
<span class="nc" id="L170">    }</span>

    /**
     * Is the bean style indicating that properties should be generated.
     * @return the flag
     */
    public boolean isBeanStyleValid() {
<span class="nc bnc" id="L177" title="All 4 branches missed.">        return &quot;full&quot;.equals(beanStyle) || &quot;smart&quot;.equals(beanStyle) ||</span>
<span class="nc bnc" id="L178" title="All 4 branches missed.">                &quot;minimal&quot;.equals(beanStyle) || &quot;light&quot;.equals(beanStyle);</span>
    }

    /**
     * Is the bean style indicating that no meta and builder should be generated.
     * @return the flag
     */
    public boolean isBeanStyleLight() {
<span class="nc" id="L186">        return &quot;light&quot;.equals(beanStyle);</span>
    }

    /**
     * Is the bean style minimal.
     * @return the flag
     */
    public boolean isBeanStyleMinimal() {
<span class="nc" id="L194">        return &quot;minimal&quot;.equals(beanStyle);</span>
    }

    /**
     * Is the bean style indicating that no meta and builder should be generated.
     * @return the flag
     */
    public boolean isBeanStyleLightOrMinimal() {
<span class="nc bnc" id="L202" title="All 4 branches missed.">        return isBeanStyleLight() || isBeanStyleMinimal();</span>
    }

    /**
     * Is the bean style indicating that properties should be generated.
     * @return the flag
     */
    public boolean isBeanStyleGenerateProperties() {
<span class="nc bnc" id="L210" title="All 6 branches missed.">        return &quot;full&quot;.equals(beanStyle) || (&quot;smart&quot;.equals(beanStyle) &amp;&amp; isImmutable() == false);</span>
    }

    /**
     * Is the bean style indicating that properties should be generated.
     * @return the flag
     */
    public boolean isBeanStyleGenerateMetaProperties() {
<span class="nc bnc" id="L218" title="All 6 branches missed.">        return (&quot;full&quot;.equals(beanStyle) || &quot;smart&quot;.equals(beanStyle)) &amp;&amp; !isMetaScopePrivate();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the bean meta scope.
     * @return the scope
     */
    public String getBeanMetaScope() {
<span class="nc" id="L227">        return beanMetaScope;</span>
    }

    /**
     * Sets the bean meta scope.
     * @param metaScope  the scope
     */
    public void setBeanMetaScope(String metaScope) {
<span class="nc" id="L235">        this.beanMetaScope = metaScope;</span>
<span class="nc" id="L236">    }</span>

    /**
     * Is the meta scope valid.
     * @return the flag
     */
    public boolean isBeanMetaScopeValid() {
<span class="nc bnc" id="L243" title="All 2 branches missed.">        return &quot;smart&quot;.equals(beanMetaScope) ||</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                &quot;private&quot;.equals(beanMetaScope) ||</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                &quot;package&quot;.equals(beanMetaScope) ||</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                &quot;public&quot;.equals(beanMetaScope);</span>
    }

    /**
     * Gets the effective scope to use in the meta.
     * @return the scope
     */
    public String getEffectiveMetaScope() {
<span class="nc" id="L254">        String scope = beanMetaScope;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(scope)) {</span>
<span class="nc" id="L256">            scope = typeScope;</span>
        }
<span class="nc bnc" id="L258" title="All 2 branches missed.">        return &quot;package&quot;.equals(scope) ? &quot;&quot; : scope + &quot; &quot;;</span>
    }

    /**
     * Checks the meta-bean scope.
     * @return the scope
     */
    public boolean isMetaScopePrivate() {
<span class="nc bnc" id="L266" title="All 4 branches missed.">        return &quot;private&quot;.equals(beanMetaScope) || isBeanStyleLight();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the bean builder scope.
     * @return the scope
     */
    public String getBeanBuilderScope() {
<span class="nc" id="L275">        return beanBuilderScope;</span>
    }

    /**
     * Sets the bean builder scope.
     * @param builderScope  the scope
     */
    public void setBeanBuilderScope(String builderScope) {
<span class="nc" id="L283">        this.beanBuilderScope = builderScope;</span>
<span class="nc" id="L284">    }</span>

    /**
     * Is the builder scope valid.
     * @return the flag
     */
    public boolean isBeanBuilderScopeValid() {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        return &quot;smart&quot;.equals(beanBuilderScope) ||</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                &quot;private&quot;.equals(beanBuilderScope) ||</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                &quot;package&quot;.equals(beanBuilderScope) ||</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">                &quot;public&quot;.equals(beanBuilderScope);</span>
    }

    /**
     * Gets the effective scope to use in the builder.
     * @return the scope
     */
    public String getEffectiveBuilderScope() {
<span class="nc" id="L302">        String scope = beanBuilderScope;</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(scope)) {</span>
<span class="nc" id="L304">            scope = typeScope;</span>
        }
<span class="nc bnc" id="L306" title="All 2 branches missed.">        return &quot;package&quot;.equals(scope) ? &quot;&quot; : scope + &quot; &quot;;</span>
    }

    /**
     * Is the effective scope to use in the builder public.
     * @return the scope
     */
    public boolean isEffectiveBuilderScopeVisible() {
<span class="nc bnc" id="L314" title="All 6 branches missed.">        return (&quot;smart&quot;.equals(beanBuilderScope) || &quot;public&quot;.equals(beanBuilderScope) || &quot;package&quot;.equals(beanBuilderScope)) &amp;&amp;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">                !isBeanStyleLight();</span>
    }

    /**
     * Is the scope to use in the builder public.
     * @return the scope
     */
    public boolean isBuilderScopeVisible() {
<span class="nc bnc" id="L323" title="All 4 branches missed.">        return &quot;public&quot;.equals(beanBuilderScope) || &quot;package&quot;.equals(beanBuilderScope);</span>
    }

    /**
     * Is the builder generated
     * @return true if generated
     */
    public boolean isSkipBuilderGeneration() {
<span class="nc bnc" id="L331" title="All 6 branches missed.">        return (isMutable() &amp;&amp; isBuilderScopeVisible() == false) || isBeanStyleLight();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the factory name.
     * @return the factory name
     */
    public boolean isFactoryRequired() {
<span class="nc bnc" id="L340" title="All 2 branches missed.">        return factoryName.length() &gt; 0;</span>
    }

    /**
     * Gets the factory name.
     * @return the factory name
     */
    public String getFactoryName() {
<span class="nc" id="L348">        return factoryName;</span>
    }

    /**
     * Sets the factory name.
     * @param name  the factory name
     */
    public void setFactoryName(String name) {
<span class="nc" id="L356">        factoryName = name;</span>
<span class="nc" id="L357">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets whether to cache the hash code.
     * @return the flag
     */
    public boolean isCacheHashCode() {
<span class="nc" id="L365">        return cacheHashCode;</span>
    }

    /**
     * Sets whether to cache the hash code.
     * @param cacheHashCode  the flag
     */
    public void setCacheHashCode(boolean cacheHashCode) {
<span class="nc" id="L373">        this.cacheHashCode = cacheHashCode;</span>
<span class="nc" id="L374">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets whether property change support is needed.
     * @return the flag
     */
    public boolean isPropertyChangeSupport() {
<span class="nc bnc" id="L382" title="All 2 branches missed.">        for (PropertyData prop : properties) {</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">            if (prop.isBound()) {</span>
<span class="nc" id="L384">                return true;</span>
            }
<span class="nc" id="L386">        }</span>
<span class="nc" id="L387">        return false;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets whether the bean is immutable.
     * @return the flag
     */
    public boolean isImmutable() {
<span class="nc" id="L396">        return immutable;</span>
    }

    /**
     * Gets whether the bean is mutable.
     * @return the flag
     */
    public boolean isMutable() {
<span class="nc bnc" id="L404" title="All 2 branches missed.">        return !immutable;</span>
    }

    /**
     * Sets whether the bean is immutable.
     * @param immutable  the flag
     */
    public void setImmutable(boolean immutable) {
<span class="nc" id="L412">        this.immutable = immutable;</span>
<span class="nc" id="L413">    }</span>

    /**
     * Checks whether the bean can be constructed.
     * @return the flag
     */
    public boolean isConstructable() {
<span class="nc" id="L420">        return constructable;</span>
    }

    /**
     * Sets whether the bean can be constructed.
     * @param constructable  the flag
     */
    public void setConstructable(boolean constructable) {
<span class="nc" id="L428">        this.constructable = constructable;</span>
<span class="nc" id="L429">    }</span>

    /**
     * Gets whether the bean has a manual constructor to use.
     * @return the flag, zero for none, one for builder based, two for argument based
     */
    public int getImmutableConstructor() {
<span class="nc" id="L436">        return immutableConstructor;</span>
    }

    /**
     * Sets whether the bean has a manual constructor to use.
     * @param manualConstructor  the flag
     */
    public void setImmutableConstructor(int manualConstructor) {
<span class="nc" id="L444">        this.immutableConstructor = manualConstructor;</span>
<span class="nc" id="L445">    }</span>

    /**
     * Gets whether the bean has a validator.
     * @return the method name
     */
    public String getImmutableValidator() {
<span class="nc" id="L452">        return immutableValidator;</span>
    }

    /**
     * Sets whether the bean has a validator.
     * @param immutableValidator  the method name
     */
    public void setImmutableValidator(String immutableValidator) {
<span class="nc" id="L460">        this.immutableValidator = immutableValidator;</span>
<span class="nc" id="L461">    }</span>

    /**
     * Gets whether the bean has an apply defaults method.
     * @return the method name
     */
    public String getImmutableDefaults() {
<span class="nc" id="L468">        return immutableDefaults;</span>
    }

    /**
     * Sets whether the bean has an apply defaults method.
     * @param immutableDefaults  the method name
     */
    public void setImmutableDefaults(String immutableDefaults) {
<span class="nc" id="L476">        this.immutableDefaults = immutableDefaults;</span>
<span class="nc" id="L477">    }</span>

    /**
     * Gets whether the bean has a pre-build method.
     * @return the method name
     */
    public String getImmutablePreBuild() {
<span class="nc" id="L484">        return immutablePreBuild;</span>
    }

    /**
     * Sets whether the bean has a pre-build method.
     * @param immutablePreBuild  the method name
     */
    public void setImmutablePreBuild(String immutablePreBuild) {
<span class="nc" id="L492">        this.immutablePreBuild = immutablePreBuild;</span>
<span class="nc" id="L493">    }</span>

    /**
     * Gets the constructor style to generate.
     * @return the flag, zero for none, one for builder based, two for argument based
     */
    public int getConstructorStyle() {
<span class="nc" id="L500">        return constructorStyle;</span>
    }

    /**
     * Sets the constructor style to generate.
     * @param constructorStyle  the constructor style
     */
    public void setConstructorStyle(int constructorStyle) {
<span class="nc" id="L508">        this.constructorStyle = constructorStyle;</span>
<span class="nc" id="L509">    }</span>

    /**
     * Gets the constructor scope to generate.
     * @return the scope
     */
    public String getConstructorScope() {
<span class="nc" id="L516">        return constructorScope;</span>
    }

    /**
     * Sets the constructor scope to generate.
     * @param constructorScope  the constructor scope
     */
    public void setConstructorScope(String constructorScope) {
<span class="nc" id="L524">        this.constructorScope = constructorScope;</span>
<span class="nc" id="L525">    }</span>

    /**
     * Is the constructor scope valid.
     * @return true if valid
     */
    public boolean isConstructorScopeValid() {
<span class="nc bnc" id="L532" title="All 2 branches missed.">        return &quot;smart&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">                &quot;private&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">                &quot;package&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">                &quot;protected&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                &quot;public&quot;.equals(constructorScope) ||</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                &quot;public@ConstructorProperties&quot;.equals(constructorScope);</span>
    }

    /**
     * Gets the effective scope to use in the constructor.
     * @return the scope
     */
    public String getEffectiveConstructorScope() {
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (&quot;smart&quot;.equals(constructorScope)) {</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            return isTypeFinal() ? &quot;private &quot; : &quot;protected &quot;;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">        } else if (&quot;package&quot;.equals(constructorScope)) {</span>
<span class="nc" id="L548">            return &quot;&quot;;</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">        } else if (&quot;public@ConstructorProperties&quot;.equals(constructorScope)) {</span>
<span class="nc" id="L550">            return &quot;public &quot;;</span>
        }
<span class="nc" id="L552">        return constructorScope + &quot; &quot;;</span>
    }

    /**
     * Checks if the scope indicates the need for the ConstructorProperties annotation.
     * @return true if the annotation is needed
     */
    public boolean isConstructorPropertiesAnnotation() {
<span class="nc" id="L560">        return &quot;public@ConstructorProperties&quot;.equals(constructorScope);</span>
    }

    /**
     * Checks whether the bean is serializable.
     * @return the flag
     */
    public boolean isSerializable() {
<span class="nc" id="L568">        return serializable;</span>
    }

    /**
     * Sets whether the bean is serializable.
     * @param serializable  the flag
     */
    public void setSerializable(boolean serializable) {
<span class="nc" id="L576">        this.serializable = serializable;</span>
<span class="nc" id="L577">    }</span>

    /**
     * Checks whether the bean has a manual serialization id.
     * @return the flag
     */
    public boolean isManualSerializationId() {
<span class="nc" id="L584">        return manualSerVersionId;</span>
    }

    /**
     * Sets whether the bean has a manual serialization id.
     * @param manualSerVersionId  the flag
     */
    public void setManualSerializationId(boolean manualSerVersionId) {
<span class="nc" id="L592">        this.manualSerVersionId = manualSerVersionId;</span>
<span class="nc" id="L593">    }</span>

    /**
     * Checks if the clone is manual.
     * @return true if manual
     */
    public boolean isManualClone() {
<span class="nc" id="L600">        return manualClone;</span>
    }

    /**
     * Sets if the clone is manual.
     * @param manualClone  true if manual
     */
    public void setManualClone(boolean manualClone) {
<span class="nc" id="L608">        this.manualClone = manualClone;</span>
<span class="nc" id="L609">    }</span>

    /**
     * Checks if the equals/hashCode is manual.
     * @return true if manual
     */
    public boolean isManualEqualsHashCode() {
<span class="nc" id="L616">        return manualEqualsHashCode;</span>
    }

    /**
     * Sets if the equals/hashCode is manual.
     * @param manualEqualsHashCode  true if manual
     */
    public void setManualEqualsHashCode(boolean manualEqualsHashCode) {
<span class="nc" id="L624">        this.manualEqualsHashCode = manualEqualsHashCode;</span>
<span class="nc" id="L625">    }</span>

    /**
     * Checks if the toString is manual.
     * @return true if manual
     */
    public boolean isManualToStringCode() {
<span class="nc" id="L632">        return manualToStringCode;</span>
    }

    /**
     * Sets if the toString is manual.
     * @param manualToStringCode  true if manual
     */
    public void setManualToStringCode(boolean manualToStringCode) {
<span class="nc" id="L640">        this.manualToStringCode = manualToStringCode;</span>
<span class="nc" id="L641">    }</span>

    /**
     * Gets the clone style.
     * @return the clone style
     */
    public String getCloneStyle() {
<span class="nc" id="L648">        return cloneStyle;</span>
    }

    /**
     * Sets the clone style.
     * @param cloneStyle  the clone style
     */
    public void setCloneStyle(String cloneStyle) {
<span class="nc" id="L656">        this.cloneStyle = cloneStyle;</span>
<span class="nc" id="L657">    }</span>

    /**
     * Is the clone style valid.
     * @return true if valid
     */
    public boolean isCloneStyleValid() {
<span class="nc bnc" id="L664" title="All 2 branches missed.">        return &quot;smart&quot;.equals(cloneStyle) ||</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">                &quot;omit&quot;.equals(cloneStyle) ||</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                &quot;generate&quot;.equals(cloneStyle);</span>
    }

    /**
     * Is the clone method to be skiped.
     * @return true to generate
     */
    public boolean isSkipCloneGeneration() {
<span class="nc bnc" id="L674" title="All 6 branches missed.">        return (&quot;smart&quot;.equals(cloneStyle) &amp;&amp; isImmutable()) || &quot;omit&quot;.equals(cloneStyle);</span>
    }

    /**
     * Sets the bean type.
     * @param parts  the type to set
     */
    public void setTypeParts(String[] parts) {
<span class="nc bnc" id="L682" title="All 2 branches missed.">        this.typeFinal = parts[0] != null;</span>
<span class="nc" id="L683">        this.typeScope = parts[1];</span>
<span class="nc" id="L684">        this.typeFull = parts[2];</span>
<span class="nc" id="L685">        this.typeRaw = parts[3];</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">        if (parts[8] != null) {</span>
<span class="nc" id="L687">            this.typeGenericName = new String[] {parts[4], parts[6], parts[8]};</span>
<span class="nc" id="L688">            this.typeGenericExtends = new String[3];</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">            this.typeGenericExtends[0] = parts[5] != null ? parts[5] : &quot;&quot;;</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">            this.typeGenericExtends[1] = parts[7] != null ? parts[7] : &quot;&quot;;</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">            this.typeGenericExtends[2] = parts[9] != null ? parts[9] : &quot;&quot;;</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        } else if (parts[6] != null) {</span>
<span class="nc" id="L693">            this.typeGenericName = new String[] {parts[4], parts[6]};</span>
<span class="nc" id="L694">            this.typeGenericExtends = new String[2];</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">            this.typeGenericExtends[0] = parts[5] != null ? parts[5] : &quot;&quot;;</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">            this.typeGenericExtends[1] = parts[7] != null ? parts[7] : &quot;&quot;;</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">        } else if (parts[4] != null) {</span>
<span class="nc" id="L698">            this.typeGenericName = new String[] {parts[4]};</span>
<span class="nc" id="L699">            this.typeGenericExtends = new String[1];</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">            this.typeGenericExtends[0] = parts[5] != null ? parts[5] : &quot;&quot;;</span>
        } else {
<span class="nc" id="L702">            this.typeGenericName = new String[0];</span>
<span class="nc" id="L703">            this.typeGenericExtends = new String[0];</span>
        }
<span class="nc" id="L705">    }</span>

    /**
     * Sets the bean superclass type.
     * @param parts  the superclass to set
     */
    public void setSuperTypeParts(String[] parts) {
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (parts.length == 1) {</span>
<span class="nc" id="L713">            this.root = true;</span>
<span class="nc" id="L714">            this.immutable = &quot;ImmutableBean&quot;.equals(parts[0]);</span>
<span class="nc" id="L715">            this.superTypeFull = &quot;&quot;;</span>
<span class="nc" id="L716">            this.superTypeRaw = &quot;&quot;;</span>
<span class="nc" id="L717">            this.superTypeGeneric = &quot;&quot;;</span>
        } else {
<span class="nc" id="L719">            this.root = &quot;DirectBean&quot;.equals(parts[0]);</span>
<span class="nc" id="L720">            this.immutable = false;</span>
<span class="nc" id="L721">            this.superTypeFull = parts[0];</span>
<span class="nc" id="L722">            this.superTypeRaw = parts[1];</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">            if (parts[4] != null) {</span>
<span class="nc" id="L724">                this.superTypeGeneric = parts[2] + &quot;, &quot; + parts[3] + &quot;, &quot; + parts[4];</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">            } else if (parts[3] != null) {</span>
<span class="nc" id="L726">                this.superTypeGeneric = parts[2] + &quot;, &quot; + parts[3];</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">            } else if (parts[2] != null) {</span>
<span class="nc" id="L728">                this.superTypeGeneric = parts[2];</span>
            } else {
<span class="nc" id="L730">                this.superTypeGeneric = &quot;&quot;;</span>
            }
        }
<span class="nc" id="L733">    }</span>

    /**
     * Gets the modifiable list of properties.
     * @return the properties, not null
     */
    public List&lt;PropertyData&gt; getProperties() {
<span class="nc" id="L740">        return properties;</span>
    }

    /**
     * Checks if the type is final.
     * @return true if manual
     */
    public boolean isTypeFinal() {
<span class="nc" id="L748">        return typeFinal;</span>
    }

    /**
     * Sets if the type is final.
     * @param typeFinal  true if final, false if subclassable
     */
    public void setTypeFinal(boolean typeFinal) {
<span class="nc" id="L756">        this.typeFinal = typeFinal;</span>
<span class="nc" id="L757">    }</span>

    /**
     * Gets the scope of the type.
     * @return true if manual
     */
    public String getTypeScope() {
<span class="nc" id="L764">        return typeScope;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this bean is a superclass.
     * @return true if this is a subclass of another bean
     */
    public boolean isSubClass() {
<span class="nc bnc" id="L773" title="All 2 branches missed.">        return !root;</span>
    }

    /**
     * Checks if this bean is the root class in a hierarchy.
     * @return true if this is the root class with no bean superclasses
     */
    public boolean isRootClass() {
<span class="nc" id="L781">        return root;</span>
    }

    /**
     * Checks if this bean directly extends {@code DirectBean}.
     * @return true if this extends DirectBean
     */
    public boolean isExtendsDirectBean() {
<span class="nc" id="L789">        return &quot;DirectBean&quot;.equals(superTypeFull);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if the bean is parameterised with generics.
     * @return true if generified
     */
    public boolean isTypeGeneric() {
<span class="nc bnc" id="L798" title="All 2 branches missed.">        return typeGenericName.length &gt; 0;</span>
    }

    /**
     * Gets the number of generic type parameters.
     * @return zero if no type parameters, one or two if it has type parameters
     */
    public int getTypeGenericCount() {
<span class="nc" id="L806">        return typeGenericName.length;</span>
    }

    /**
     * Gets the bean type, such as '{@code Foo&lt;T extends Bar&gt;}'.
     * @return the type
     */
    public String getType() {
<span class="nc" id="L814">        return typeFull;</span>
    }

    /**
     * Gets the parameterisation of the bean including extends clause, such as '{@code &lt;T extends Bar&gt;}'.
     * @param includeBrackets  whether to include the brackets
     * @return the generic type, or a blank string if not generic, not null
     */
    public String getTypeGeneric(boolean includeBrackets) {
<span class="nc bnc" id="L823" title="All 2 branches missed.">        if (isTypeGeneric() == false) {</span>
<span class="nc" id="L824">            return &quot;&quot;;</span>
        }
<span class="nc" id="L826">        String result = typeGenericName[0] + typeGenericExtends[0];</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">        if (typeGenericExtends.length &gt; 1) {</span>
<span class="nc" id="L828">            result += &quot;, &quot; + typeGenericName[1] + typeGenericExtends[1];</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">            if (typeGenericExtends.length &gt; 2) {</span>
<span class="nc" id="L830">                result += &quot;, &quot; + typeGenericName[2] + typeGenericExtends[2];</span>
            }
        }
<span class="nc bnc" id="L833" title="All 4 branches missed.">        return includeBrackets &amp;&amp; result.length() &gt; 0 ? '&lt;' + result + '&gt;' : result;</span>
    }

    /**
     * Gets the name of the parameterisation of the bean, such as '{@code &lt;T, U&gt;}'.
     * @param includeBrackets  whether to include the brackets
     * @return the generic type name, or a blank string if not generic, not null
     */
    public String getTypeGenericName(boolean includeBrackets) {
<span class="nc bnc" id="L842" title="All 2 branches missed.">        if (isTypeGeneric() == false) {</span>
<span class="nc" id="L843">            return &quot;&quot;;</span>
        }
<span class="nc" id="L845">        String result = typeGenericName[0];</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">        if (typeGenericExtends.length &gt; 1) {</span>
<span class="nc" id="L847">            result += &quot;, &quot; + typeGenericName[1];</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">            if (typeGenericExtends.length &gt; 2) {</span>
<span class="nc" id="L849">                result += &quot;, &quot; + typeGenericName[2];</span>
            }
        }
<span class="nc bnc" id="L852" title="All 4 branches missed.">        return includeBrackets &amp;&amp; result.length() &gt; 0 ? '&lt;' + result + '&gt;' : result;</span>
    }

    /**
     * Gets the diamond operator if generic.
     * @return the generic type name, or a blank string if not generic, not null
     */
    public String getTypeGenericDiamond() {
<span class="nc bnc" id="L860" title="All 2 branches missed.">        return isTypeGeneric() ? &quot;&lt;&gt;&quot; : &quot;&quot;;</span>
    }

    /**
     * Gets the type with the diamond operator if generic.
     * @return the type name, with generic diamond if necessary, not null
     */
    public String getTypeWithDiamond() {
<span class="nc bnc" id="L868" title="All 2 branches missed.">        return isTypeGeneric() ? getTypeRaw() + &quot;&lt;&gt;&quot; : getTypeRaw();</span>
    }

    /**
     * Gets the name of the parameterisation of the bean, such as '{@code &lt;T&gt;}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @param includeBrackets  whether to include brackets
     * @return the generic type name, not null
     */
    public String getTypeGenericName(int typeParamIndex, boolean includeBrackets) {
<span class="nc" id="L878">        String result = typeGenericName[typeParamIndex];</span>
<span class="nc bnc" id="L879" title="All 4 branches missed.">        return includeBrackets &amp;&amp; result.length() &gt; 0 ? '&lt;' + result + '&gt;' : result;</span>
    }

    /**
     * Gets the extends clause of the parameterisation of the bean, such as '{@code  extends Foo}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeGenericErased(int typeParamIndex) {
<span class="nc" id="L888">        String extend = typeGenericExtends[typeParamIndex];</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">        return extend.startsWith(&quot; extends &quot;) ? extend.substring(9) : &quot;Object&quot;;</span>
    }

    /**
     * Gets the extends clause of the parameterisation of the bean, such as '{@code  extends Foo}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeGenericExtends(int typeParamIndex) {
<span class="nc" id="L898">        return typeGenericExtends[typeParamIndex];</span>
    }

    /**
     * Gets the extends clause of the parameterisation of the bean, such as '{@code  extends Foo}'.
     * @param typeParamIndex  the zero-based index of the type parameter
     * @param typeParamNames  the type parameter names
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeGenericExtends(int typeParamIndex, String[] typeParamNames) {
<span class="nc" id="L908">        String genericClause = typeGenericExtends[typeParamIndex];</span>
<span class="nc" id="L909">        genericClause = genericClause.replace(&quot;&lt;&quot; + typeGenericName[typeParamIndex] + &quot;&gt;&quot;, &quot;&lt;&quot; + typeParamNames[typeParamIndex] + &quot;&gt;&quot;);</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">        for (int i = 0; i &lt; typeGenericName.length; i++) {</span>
<span class="nc" id="L911">            genericClause = genericClause.replace(&quot;&lt;&quot; + typeGenericName[i] + &quot;&gt;&quot;, &quot;&lt;&quot; + typeParamNames[i] + &quot;&gt;&quot;);</span>
<span class="nc" id="L912">            genericClause = genericClause.replace(&quot; extends &quot; + typeGenericName[i] + &quot;&gt;&quot;, &quot; extends &quot; + typeParamNames[i] + &quot;&gt;&quot;);</span>
<span class="nc" id="L913">            genericClause = genericClause.replace(&quot; super &quot; + typeGenericName[i] + &quot;&gt;&quot;, &quot; super &quot; + typeParamNames[i] + &quot;&gt;&quot;);</span>
        }
<span class="nc" id="L915">        return genericClause;</span>
    }

    /**
     * Gets the full type of the bean with simple parameterization, such as '{@code Foo&lt;T&gt;}'.
     * @return the generic type extends clause, or a blank string if not generic or no extends, not null
     */
    public String getTypeNoExtends() {
<span class="nc" id="L923">        return typeRaw + getTypeGenericName(true);</span>
    }

    /**
     * Gets the raw type of the bean without generics, such as '{@code Foo}'.
     * @return the raw type, not null
     */
    public String getTypeRaw() {
<span class="nc" id="L931">        return typeRaw;</span>
    }

    /**
     * Gets the full type of the bean with wildcarded parameterization, such as '{@code Foo&lt;?&gt;}'.
     * @return the wildcarded type, not null
     */
    public String getTypeWildcard() {
<span class="nc bnc" id="L939" title="All 2 branches missed.">        if (isTypeGeneric() == false) {</span>
<span class="nc" id="L940">            return typeRaw;</span>
        }
<span class="nc" id="L942">        String result = &quot;?&quot;;</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">        if (typeGenericExtends.length &gt; 1) {</span>
<span class="nc" id="L944">            result += &quot;, ?&quot;;</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">            if (typeGenericExtends.length &gt; 2) {</span>
<span class="nc" id="L946">                result += &quot;, ?&quot;;</span>
            }
        }
<span class="nc" id="L949">        return typeRaw + '&lt;' + result + '&gt;';</span>
    }

    /**
     * Checks if the type specified is one of the bean's type parameters.
     * @param type  the type
     * @return true if a type parameter of this bean
     */
    public boolean isTypeGenerifiedBy(String type) {
<span class="nc bnc" id="L958" title="All 4 branches missed.">        if (typeGenericName.length &gt; 2 &amp;&amp; typeGenericName[2].equals(type)) {</span>
<span class="nc" id="L959">            return true;</span>
        }
<span class="nc bnc" id="L961" title="All 4 branches missed.">        if (typeGenericName.length &gt; 1 &amp;&amp; typeGenericName[1].equals(type)) {</span>
<span class="nc" id="L962">            return true;</span>
        }
<span class="nc bnc" id="L964" title="All 4 branches missed.">        if (typeGenericName.length &gt; 0 &amp;&amp; typeGenericName[0].equals(type)) {</span>
<span class="nc" id="L965">            return true;</span>
        }
<span class="nc" id="L967">        return false;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if the super bean is parameterised with generics.
     * @return true if generified
     */
    public boolean isSuperTypeGeneric() {
<span class="nc bnc" id="L976" title="All 2 branches missed.">        return superTypeGeneric.length() &gt; 0;</span>
    }

    /**
     * Gets the bean superclass type.
     * @return the superclass
     */
    public String getSuperType() {
<span class="nc" id="L984">        return superTypeFull;</span>
    }

    /**
     * Gets the parameterisation of the super bean.
     * @param includeBrackets  whether to include the brackets
     * @return the generic type, or a blank string if not generic, not null
     */
    public String getSuperTypeGeneric(boolean includeBrackets) {
<span class="nc bnc" id="L993" title="All 4 branches missed.">        return includeBrackets &amp;&amp; superTypeGeneric.length() &gt; 0 ? '&lt;' + superTypeGeneric + '&gt;' : superTypeGeneric;</span>
    }

    /**
     * Gets the raw type of the super bean without generics.
     * @return the raw type, not null
     */
    public String getSuperTypeRaw() {
<span class="nc" id="L1001">        return superTypeRaw;</span>
    }

    /**
     * Checks if any property is validated.
     * @return true if validated
     */
    public boolean isValidated() {
<span class="nc bnc" id="L1009" title="All 2 branches missed.">        for (PropertyData property : properties) {</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">            if (property.isValidated()) {</span>
<span class="nc" id="L1011">                return true;</span>
            }
<span class="nc" id="L1013">        }</span>
<span class="nc" id="L1014">        return false;</span>
    }

    /**
     * Gets the scope of nested Meta and Builder classes.
     * @return the scope, not null
     */
    public String getNestedClassConstructorScope() {
<span class="nc bnc" id="L1022" title="All 2 branches missed.">        return (isTypeFinal() ? &quot;private&quot; : &quot;protected&quot;);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>