<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda-Beans</a> &gt; <a href="index.source.html" class="el_package">org.joda.beans.gen</a> &gt; <span class="el_source">BeanParser.java</span></div><h1>BeanParser.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-present Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.beans.gen;

import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_BY_ARGS;
import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_BY_BUILDER;
import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_NONE;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Parse bean information from source file.
 */
class BeanParser {

    /** Start marker. */
    private static final String AUTOGENERATED_START_TEXT = &quot;AUTOGENERATED START&quot;;
    /** Start marker. */
    private static final String AUTOGENERATED_START = &quot;\t//------------------------- AUTOGENERATED START -------------------------&quot;;
    /** End marker. */
    private static final String AUTOGENERATED_END = &quot;\t//-------------------------- AUTOGENERATED END --------------------------&quot;;
    /** Pattern to find bean type. */
    // handle three comma separated generic parameters
    // handle generic parameter extends clause
    // handle extends clause with further level of generic parameters
    // handle extends clause union types without generic parameters
<span class="nc" id="L46">    private static final Pattern BEAN_TYPE = Pattern.compile(&quot;.*class +(&quot; +</span>
            &quot;([A-Z][A-Za-z0-9_]+)&quot; +
                &quot;(?:&lt;&quot; +
                    &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                    &quot;(?:[,] +&quot; +
                        &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                        &quot;(?:[,] +&quot; +
                            &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                        &quot;)?&quot; +
                    &quot;)?&quot; +
                &quot;&gt;)?&quot; +
            &quot;).*&quot;);
    /** Pattern to find super type. */
<span class="nc" id="L59">    private static final Pattern SUPER_TYPE = Pattern.compile(&quot;.*extends +(&quot; +</span>
            &quot;([A-Z][A-Za-z0-9_]+)&quot; +
                &quot;(?:&lt;&quot; +
                    &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)&quot; +
                    &quot;(?:[,] +&quot; +
                        &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)?&quot; +
                        &quot;(?:[,] +&quot; +
                            &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)?&quot; +
                        &quot;)?&quot; +
                    &quot;)?&quot; +
                &quot;&gt;)?&quot; +
            &quot;).*&quot;);
    /** Pattern to find root type. */
<span class="nc" id="L72">    private static final Pattern SUPER_IMPL_TYPE = Pattern.compile(&quot;.*implements.*[ ,]((Immutable)?Bean)([ ,{]|$).*&quot;);</span>
    /** Pattern to find serializable interface. */
<span class="nc" id="L74">    private static final Pattern SERIALIZABLE_TYPE = Pattern.compile(&quot;.*implements.*[ ,]Serializable([ ,{]|$).*&quot;);</span>
    /** The style pattern. */
<span class="nc" id="L76">    private static final Pattern STYLE_PATTERN = Pattern.compile(&quot;.*[ ,(]style[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The metaScope pattern. */
<span class="nc" id="L78">    private static final Pattern META_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]metaScope[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The builderScope pattern. */
<span class="nc" id="L80">    private static final Pattern BUILDER_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]builderScope[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The builderStyle pattern. */
<span class="nc" id="L82">    private static final Pattern BUILDER_NAME_PATTERN = Pattern.compile(&quot;.*[ ,(]builderName[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The constructorScope pattern. */
<span class="nc" id="L84">    private static final Pattern CONSTRUCTOR_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]constructorScope[ ]*[=][ ]*[\&quot;]([a-zA-Z@]*)[\&quot;].*&quot;);</span>
    /** The factoryName pattern. */
<span class="nc" id="L86">    private static final Pattern FACTORY_NAME_PATTERN = Pattern.compile(&quot;.*[ ,(]factoryName[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The hierarchy pattern. */
<span class="nc" id="L88">    private static final Pattern HIERARCHY_PATTERN = Pattern.compile(&quot;.*[ ,(]hierarchy[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The cacheHashCode pattern. */
<span class="nc" id="L90">    private static final Pattern CACHE_HASH_CODE_PATTERN = Pattern.compile(&quot;.*[ ,(]cacheHashCode[ ]*[=][ ]*(true|false).*&quot;);</span>
    /** The cloneStyle pattern. */
<span class="nc" id="L92">    private static final Pattern CLONE_STYLE_PATTERN = Pattern.compile(&quot;.*[ ,(]cloneStyle[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>

    /** The validator pattern. */
<span class="nc" id="L95">    private static final Pattern VALIDATOR_PATTERN = Pattern.compile(</span>
            &quot;.*private[ ]+void[ ]+&quot; +
            &quot;([a-zA-Z][a-zA-Z0-9]*)[(][ ]*[)].*&quot;);
    /** The defaults pattern. */
<span class="nc" id="L99">    private static final Pattern DEFAULTS_PATTERN = Pattern.compile(</span>
            &quot;.*private[ ]+static[ ]+void[ ]+&quot; +
            &quot;([a-zA-Z][a-zA-Z0-9]*)[(][ ]*Builder[ ]+[a-zA-Z][a-zA-Z0-9]*[ ]*[)].*&quot;);

    /** The content to process. */
    private final File file;
    /** The content to process. */
    private final List&lt;String&gt; content;
    /** The content to process. */
    private final BeanGenConfig config;
    /** The content to process. */
    private int beanDefIndex;
    /** The start position of auto-generation. */
    private int autoStartIndex;
    /** The end position of auto-generation. */
    private int autoEndIndex;
    /** The list of property generators. */
    private List&lt;PropertyGen&gt; properties;

    /**
     * Constructor.
     * @param file  the file to process, not null
     * @param content  the content to process, not null
     */
<span class="nc" id="L123">    BeanParser(File file, List&lt;String&gt; content, BeanGenConfig config) {</span>
<span class="nc" id="L124">        this.file = file;</span>
<span class="nc" id="L125">        this.content = content;</span>
<span class="nc" id="L126">        this.config = config;</span>
<span class="nc" id="L127">    }</span>

    //-----------------------------------------------------------------------
    File getFile() {
<span class="nc" id="L131">        return file;</span>
    }

    String getFieldPrefix() {
<span class="nc" id="L135">        return config.getPrefix();</span>
    }

    BeanGenConfig getConfig() {
<span class="nc" id="L139">        return config;</span>
    }

    //-----------------------------------------------------------------------
    BeanGen parse() {
<span class="nc" id="L144">        BeanData data = new BeanData();</span>
<span class="nc" id="L145">        beanDefIndex = parseBeanDefinition();</span>
<span class="nc" id="L146">        data.getCurrentImports().addAll(parseImports(beanDefIndex));</span>
<span class="nc" id="L147">        data.setImportInsertLocation(parseImportLocation(beanDefIndex));</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (beanDefIndex &lt; 0) {</span>
<span class="nc" id="L149">            return new BeanGen(file, content, config, data);</span>
        }
<span class="nc" id="L151">        data.setBeanStyle(parseBeanStyle(beanDefIndex));</span>
<span class="nc" id="L152">        data.resolveBeanStyle(config.getDefaultStyle());</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (data.isBeanStyleValid() == false) {</span>
<span class="nc" id="L154">            throw new BeanCodeGenException(&quot;Invalid bean style: &quot; + data.getBeanStyle(), file, beanDefIndex);</span>
        }
<span class="nc" id="L156">        data.setConstructorScope(parseConstrucorScope(beanDefIndex));</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (data.isConstructorScopeValid() == false) {</span>
<span class="nc" id="L158">            throw new BeanCodeGenException(&quot;Invalid constructor scope: &quot; + data.getConstructorScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L160">        data.setBeanMetaScope(parseBeanMetaScope(beanDefIndex));</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (data.isBeanMetaScopeValid() == false) {</span>
<span class="nc" id="L162">            throw new BeanCodeGenException(&quot;Invalid meta-bean scope: &quot; + data.getBeanMetaScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L164">        data.setBeanBuilderScope(parseBeanBuilderScope(beanDefIndex));</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (data.isBeanBuilderScopeValid() == false) {</span>
<span class="nc" id="L166">            throw new BeanCodeGenException(&quot;Invalid bean builder scope: &quot; + data.getBeanBuilderScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L168">        data.setBeanBuilderName(parseBeanBuilderName(beanDefIndex));</span>
<span class="nc" id="L169">        data.setFactoryName(parseFactoryName(beanDefIndex));</span>
<span class="nc" id="L170">        data.setCacheHashCode(parseCacheHashCode(beanDefIndex));</span>
<span class="nc" id="L171">        data.setCloneStyle(parseCloneStyle(beanDefIndex));</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (data.isCloneStyleValid() == false) {</span>
<span class="nc" id="L173">            throw new BeanCodeGenException(&quot;Invalid clone style: &quot; + data.getCloneStyle(), file, beanDefIndex);</span>
        }
<span class="nc" id="L175">        data.setImmutableConstructor(parseImmutableConstructor(beanDefIndex));</span>
<span class="nc" id="L176">        data.setConstructable(parseConstructable(beanDefIndex));</span>
<span class="nc" id="L177">        data.setTypeParts(parseBeanType(beanDefIndex));</span>
<span class="nc" id="L178">        String classHeaderAfterType = classHeaderAfterType(beanDefIndex, data.getType());</span>
<span class="nc" id="L179">        data.setSuperTypeParts(parseBeanSuperType(classHeaderAfterType));</span>
<span class="nc" id="L180">        data.setSerializable(parseSerializable(classHeaderAfterType));</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (parseBeanHierarchy(beanDefIndex).equals(&quot;immutable&quot;)) {</span>
<span class="nc" id="L182">            data.setImmutable(true);</span>
<span class="nc" id="L183">            data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        } else if (data.getImmutableConstructor() == CONSTRUCTOR_NONE) {</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            if (data.isImmutable()) {</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                if (data.isTypeFinal()) {</span>
<span class="nc" id="L187">                    data.setConstructorStyle(CONSTRUCTOR_BY_ARGS);</span>
                } else {
<span class="nc" id="L189">                    data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
                }
            } else {
<span class="nc bnc" id="L192" title="All 2 branches missed.">                if (data.isBeanStyleLight()) {</span>
<span class="nc" id="L193">                    data.setConstructorStyle(CONSTRUCTOR_BY_ARGS);</span>
                } else {
<span class="nc" id="L195">                    data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
                }
            }
        } else {
<span class="nc" id="L199">            data.setConstructorStyle(data.getImmutableConstructor());</span>
        }
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (data.isImmutable()) {</span>
<span class="nc" id="L202">            data.setImmutableValidator(parseImmutableValidator(beanDefIndex));</span>
<span class="nc" id="L203">            data.setImmutableDefaults(parseImmutableDefaults(beanDefIndex));</span>
<span class="nc" id="L204">            data.setImmutablePreBuild(parseImmutablePreBuild(beanDefIndex));</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">            if (data.isBeanStyleLight() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L206">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Light beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L209" title="All 4 branches missed.">            if (data.isBeanStyleMinimal() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L210">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Minimal beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L213" title="All 4 branches missed.">            if (data.isFactoryRequired() &amp;&amp; !data.isRootClass()) {</span>
<span class="nc" id="L214">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean has no bean superclass&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L217" title="All 4 branches missed.">            if (data.isFactoryRequired() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L218">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean is final&quot;, file, beanDefIndex);
            }
        } else {
<span class="nc bnc" id="L222" title="All 4 branches missed.">            if (data.isBeanStyleLight() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L223">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Light beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L226" title="All 4 branches missed.">            if (data.isBeanStyleMinimal() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L227">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Minimal beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (data.isFactoryRequired()) {</span>
<span class="nc" id="L231">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean is immutable&quot;, file, beanDefIndex);
            }
        }
<span class="nc" id="L235">        properties = parseProperties(data);</span>
<span class="nc" id="L236">        autoStartIndex = parseStartAutogen();</span>
<span class="nc" id="L237">        autoEndIndex = parseEndAutogen();</span>
<span class="nc" id="L238">        data.setManualSerializationId(parseManualSerializationId(beanDefIndex));</span>
<span class="nc" id="L239">        data.setManualClone(parseManualClone(beanDefIndex));</span>
<span class="nc" id="L240">        data.setManualEqualsHashCode(parseManualEqualsHashCode(beanDefIndex));</span>
<span class="nc" id="L241">        data.setManualToStringCode(parseManualToStringCode(beanDefIndex));</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (data.isImmutable()) {</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            for (PropertyGen prop : properties) {</span>
<span class="nc bnc" id="L244" title="All 4 branches missed.">                if (prop.getData().isDerived() == false &amp;&amp; prop.getData().isFinal() == false) {</span>
<span class="nc" id="L245">                    throw new BeanCodeGenException(&quot;ImmutableBean must have final properties: &quot; +</span>
<span class="nc" id="L246">                            data.getTypeRaw() + &quot;.&quot; + prop.getData().getFieldName(),</span>
<span class="nc" id="L247">                            file, prop.getData().getLineIndex());</span>
                }
<span class="nc" id="L249">            }</span>
        } else {
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if (data.getImmutableConstructor() &gt; CONSTRUCTOR_NONE) {</span>
<span class="nc" id="L252">                throw new BeanCodeGenException(&quot;Mutable beans must not specify @ImmutableConstructor: &quot; +</span>
<span class="nc" id="L253">                        data.getTypeRaw(), file, beanDefIndex);</span>
            }
<span class="nc bnc" id="L255" title="All 4 branches missed.">            if (!&quot;smart&quot;.equals(data.getConstructorScope()) &amp;&amp; !data.isBeanStyleLight()) {</span>
<span class="nc" id="L256">                throw new BeanCodeGenException(&quot;Mutable beans must not specify @BeanDefinition(constructorScope): &quot; +</span>
<span class="nc" id="L257">                                data.getTypeRaw(), file, beanDefIndex);</span>
            }
        }
<span class="nc bnc" id="L260" title="All 2 branches missed.">        if (data.isCacheHashCode()) {</span>
<span class="nc bnc" id="L261" title="All 4 branches missed.">            data.setCacheHashCode(data.isImmutable() &amp;&amp; data.isManualEqualsHashCode() == false);</span>
        }
<span class="nc" id="L263">        return new BeanGen(file, content, config, data, properties, autoStartIndex, autoEndIndex);</span>
    }

    private String classHeaderAfterType(int defLine, String fullType) {
<span class="nc" id="L267">        StringBuilder buf = new StringBuilder(128);</span>
<span class="nc" id="L268">        boolean matchedType = false;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc" id="L270">            String line = content.get(index);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">            if (matchedType == false) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">                if (line.contains(fullType) == false) {</span>
<span class="nc" id="L273">                    continue;</span>
                }
<span class="nc" id="L275">                matchedType = true;</span>
<span class="nc" id="L276">                line = line.substring(line.indexOf(fullType) + fullType.length());</span>
            }
<span class="nc" id="L278">            buf.append(line).append(' ');</span>
<span class="nc bnc" id="L279" title="All 4 branches missed.">            if (line.trim().endsWith(&quot;{&quot;) &amp;&amp; !line.trim().startsWith(&quot;@&quot;)) {</span>
<span class="nc" id="L280">                break;</span>
            }
        }
<span class="nc" id="L283">        return buf.toString().trim();</span>
    }

    //-----------------------------------------------------------------------
    private int parseBeanDefinition() {
<span class="nc bnc" id="L288" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L289">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (line.startsWith(&quot;@BeanDefinition&quot;)) {</span>
<span class="nc" id="L291">                return index;</span>
            }
        }
<span class="nc" id="L294">        return -1;</span>
    }

    private Set&lt;String&gt; parseImports(int defLine) {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        int end = defLine &lt; 0 ? content.size() : defLine;</span>
<span class="nc" id="L299">        Set&lt;String&gt; imports = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        for (int index = 0; index &lt; end; index++) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (content.get(index).startsWith(&quot;import &quot;)) {</span>
<span class="nc" id="L302">                String imp = content.get(index).substring(7).trim();</span>
<span class="nc" id="L303">                imp = imp.substring(0, imp.indexOf(';'));</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                if (imp.endsWith(&quot;.*&quot;) == false) {</span>
<span class="nc" id="L305">                    imports.add(imp);</span>
                }
            }
        }
<span class="nc" id="L309">        return imports;</span>
    }

    private int parseImportLocation(int defLine) {
<span class="nc bnc" id="L313" title="All 2 branches missed.">        int end = defLine &lt; 0 ? content.size() : defLine;</span>
<span class="nc" id="L314">        int location = 0;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">        for (int index = 0; index &lt; end; index++) {</span>
<span class="nc bnc" id="L316" title="All 4 branches missed.">            if (content.get(index).startsWith(&quot;import &quot;) || content.get(index).startsWith(&quot;package &quot;)) {</span>
<span class="nc" id="L317">                location = index;</span>
            }
        }
<span class="nc" id="L320">        return location;</span>
    }

    private String parseBeanStyle(int defLine) {
<span class="nc" id="L324">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L325">        Matcher matcher = STYLE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L327">            return matcher.group(1);</span>
        }
<span class="nc" id="L329">        return &quot;smart&quot;;</span>
    }

    private String parseConstrucorScope(int defLine) {
<span class="nc" id="L333">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L334">        Matcher matcher = CONSTRUCTOR_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L336">            return matcher.group(1);</span>
        }
<span class="nc" id="L338">        return &quot;smart&quot;;</span>
    }

    private String parseBeanMetaScope(int defLine) {
<span class="nc" id="L342">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L343">        Matcher matcher = META_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L345">            return matcher.group(1);</span>
        }
<span class="nc" id="L347">        return &quot;smart&quot;;</span>
    }

    private String parseBeanBuilderScope(int defLine) {
<span class="nc" id="L351">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L352">        Matcher matcher = BUILDER_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L354">            return matcher.group(1);</span>
        }
<span class="nc" id="L356">        return &quot;smart&quot;;</span>
    }

    private String parseBeanBuilderName(int defLine) {
<span class="nc" id="L360">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L361">        Matcher matcher = BUILDER_NAME_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L363">            return matcher.group(1);</span>
        }
<span class="nc" id="L365">        return &quot;&quot;;</span>
    }

    private String parseFactoryName(int defLine) {
<span class="nc" id="L369">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L370">        Matcher matcher = FACTORY_NAME_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L372">            return matcher.group(1);</span>
        }
<span class="nc" id="L374">        return &quot;&quot;;</span>
    }

    private String parseBeanHierarchy(int defLine) {
<span class="nc" id="L378">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L379">        Matcher matcher = HIERARCHY_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L381">            return matcher.group(1);</span>
        }
<span class="nc" id="L383">        return &quot;&quot;;</span>
    }

    private boolean parseCacheHashCode(int defLine) {
<span class="nc" id="L387">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L388">        Matcher matcher = CACHE_HASH_CODE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L390">            return Boolean.valueOf(matcher.group(1));</span>
        }
<span class="nc" id="L392">        return false;</span>
    }

    private String parseCloneStyle(int defLine) {
<span class="nc" id="L396">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L397">        Matcher matcher = CLONE_STYLE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L399">            return matcher.group(1);</span>
        }
<span class="nc" id="L401">        return &quot;smart&quot;;</span>
    }

    private boolean parseConstructable(int defLine) {
<span class="nc bnc" id="L405" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            if (content.get(index).contains(&quot; abstract class &quot;)) {</span>
<span class="nc" id="L407">                return false;</span>
            }
        }
<span class="nc" id="L410">        return true;</span>
    }

    private String[] parseBeanType(int defLine) {
<span class="nc" id="L414">        Matcher matcher = BEAN_TYPE.matcher(&quot;&quot;);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc" id="L416">            String line = content.get(index);</span>
<span class="nc" id="L417">            matcher.reset(line);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">            if (matcher.matches()) {</span>
<span class="nc" id="L419">                String startStr = line.substring(0, matcher.start(1));</span>
<span class="nc bnc" id="L420" title="All 4 branches missed.">                String fnl = startStr.contains(&quot; final &quot;) || startStr.startsWith(&quot;final &quot;) ? &quot;final&quot; : null;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                String scope = startStr.contains(&quot;public &quot;) ? &quot;public&quot; : &quot;package&quot;;</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                scope = startStr.contains(&quot;protected &quot;) ? &quot;protected&quot; : scope;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                scope = startStr.contains(&quot;private &quot;) ? &quot;private&quot; : scope;</span>
<span class="nc" id="L424">                return new String[] {fnl, scope, matcher.group(1), matcher.group(2), matcher.group(3),</span>
<span class="nc" id="L425">                        matcher.group(4), matcher.group(5), matcher.group(6), matcher.group(7), matcher.group(8)};</span>
            }
<span class="nc bnc" id="L427" title="All 2 branches missed.">            if (line.contains(AUTOGENERATED_START_TEXT)) {</span>
<span class="nc" id="L428">                break;</span>
            }
        }
<span class="nc" id="L431">        throw new BeanCodeGenException(&quot;Unable to locate bean class name&quot;, file, beanDefIndex);</span>
    }

    private String[] parseBeanSuperType(String classHeaderAfterType) {
        // this uses classHeaderAfterType as extends has two meanings in class headers
        // search for implements
<span class="nc" id="L437">        Matcher matcherImplements = SUPER_IMPL_TYPE.matcher(classHeaderAfterType);</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (matcherImplements.matches()) {</span>
<span class="nc" id="L439">            return new String[] {matcherImplements.group(1)};</span>
        }
        // search for extends
<span class="nc" id="L442">        Matcher matcherExtends = SUPER_TYPE.matcher(classHeaderAfterType);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">        if (matcherExtends.matches()) {</span>
<span class="nc" id="L444">            return new String[] {matcherExtends.group(1), matcherExtends.group(2), matcherExtends.group(3),</span>
<span class="nc" id="L445">                    matcherExtends.group(4), matcherExtends.group(5)};</span>
        }
<span class="nc" id="L447">        throw new BeanCodeGenException(&quot;Unable to locate bean superclass&quot;, file, beanDefIndex);</span>
    }

    private boolean parseSerializable(String classHeaderAfterType) {
<span class="nc" id="L451">        return SERIALIZABLE_TYPE.matcher(classHeaderAfterType).matches();</span>
    }

    private boolean parseManualSerializationId(int defLine) {
<span class="nc bnc" id="L455" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            if (content.get(index).trim().startsWith(&quot;private static final long serialVersionUID&quot;)) {</span>
<span class="nc" id="L457">                return true;</span>
            }
        }
<span class="nc" id="L460">        return false;</span>
    }

    private int parseImmutableConstructor(int defLine) {
<span class="nc" id="L464">        int found = CONSTRUCTOR_NONE;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableConstructor&quot;)) {</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                if (found &gt; 0) {</span>
<span class="nc" id="L468">                    throw new BeanCodeGenException(&quot;Only one @ImmutableConstructor may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L470">                found = CONSTRUCTOR_BY_ARGS;</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L472">                    String nextLine = content.get(index + 1);</span>
<span class="nc bnc" id="L473" title="All 4 branches missed.">                    if (nextLine.contains(&quot;Builder &quot;) || nextLine.contains(&quot;Builder&lt;&quot;)) {</span>
<span class="nc" id="L474">                        found = CONSTRUCTOR_BY_BUILDER;</span>
                    }
                }
            }
        }
<span class="nc" id="L479">        return found;</span>
    }

    private String parseImmutableValidator(int defLine) {
<span class="nc" id="L483">        boolean found = false;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableValidator&quot;)) {</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L487">                    throw new BeanCodeGenException(&quot;Only one @ImmutableValidator may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L489">                found = true;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L491">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L492">                    Matcher matcher = VALIDATOR_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L494">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L496">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutableValidator method must be private void and no-args&quot;, file, index + 1);
                }
            }
        }
<span class="nc" id="L501">        return null;</span>
    }

    private String parseImmutableDefaults(int defLine) {
<span class="nc" id="L505">        boolean found = false;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableDefaults&quot;)) {</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L509">                    throw new BeanCodeGenException(&quot;Only one @ImmutableDefaults may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L511">                found = true;</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L513">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L514">                    Matcher matcher = DEFAULTS_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L516">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L518">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutableDefaults method must be private static void and have one argument of type 'Builder'&quot;,
                        file, index + 1);
                }
            }
        }
<span class="nc" id="L524">        return null;</span>
    }

    private String parseImmutablePreBuild(int defLine) {
<span class="nc" id="L528">        boolean found = false;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutablePreBuild&quot;)) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L532">                    throw new BeanCodeGenException(&quot;Only one @ImmutablePreBuild may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L534">                found = true;</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L536">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L537">                    Matcher matcher = DEFAULTS_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L539">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L541">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutablePreBuild method must be private static void and have one argument of type 'Builder'&quot;,
                        file, index + 1);
                }
            }
        }
<span class="nc" id="L547">        return null;</span>
    }

    private List&lt;PropertyGen&gt; parseProperties(BeanData data) {
<span class="nc" id="L551">        List&lt;PropertyGen&gt; props = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L553">            String line = content.get(index).trim();</span>
<span class="nc" id="L554">            PropertyParser parser = new PropertyParser(this);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (line.startsWith(&quot;@PropertyDefinition&quot;)) {</span>
<span class="nc" id="L556">                PropertyGen prop = parser.parse(data, content, index);</span>
<span class="nc" id="L557">                props.add(prop);</span>
<span class="nc" id="L558">                data.getProperties().add(prop.getData());</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">            } else if (line.startsWith(&quot;@DerivedProperty&quot;)) {</span>
<span class="nc" id="L560">                PropertyGen prop = parser.parseDerived(data, content, index);</span>
<span class="nc" id="L561">                props.add(prop);</span>
<span class="nc" id="L562">                data.getProperties().add(prop.getData());</span>
            }
        }
<span class="nc" id="L565">        return props;</span>
    }

    private int parseStartAutogen() {
<span class="nc bnc" id="L569" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L570">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">            if (line.contains(&quot; AUTOGENERATED START &quot;)) {</span>
<span class="nc" id="L572">                content.set(index, AUTOGENERATED_START);</span>
<span class="nc" id="L573">                return index;</span>
            }
        }
<span class="nc bnc" id="L576" title="All 2 branches missed.">        for (int index = content.size() - 1; index &gt;= 0; index--) {</span>
<span class="nc" id="L577">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">            if (line.equals(&quot;}&quot;)) {</span>
<span class="nc" id="L579">                content.add(index, AUTOGENERATED_START);</span>
<span class="nc" id="L580">                return index;</span>
            }
<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (line.length() &gt; 0) {</span>
<span class="nc" id="L583">                break;</span>
            }
        }
<span class="nc" id="L586">        throw new BeanCodeGenException(&quot;Unable to locate start autogeneration point&quot;, file, beanDefIndex);</span>
    }

    private int parseEndAutogen() {
<span class="nc bnc" id="L590" title="All 2 branches missed.">        for (int index = autoStartIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L591">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">            if (line.contains(&quot; AUTOGENERATED END &quot;)) {</span>
<span class="nc" id="L593">                content.set(index, AUTOGENERATED_END);</span>
<span class="nc" id="L594">                return index;</span>
            }
        }
<span class="nc" id="L597">        content.add(autoStartIndex + 1, AUTOGENERATED_END);</span>
<span class="nc" id="L598">        return autoStartIndex + 1;</span>
    }

    private boolean parseManualClone(int defLine) {
<span class="nc bnc" id="L602" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L603">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L604" title="All 4 branches missed.">            if (line.startsWith(&quot;public &quot;) &amp;&amp; line.endsWith(&quot; clone() {&quot;)) {</span>
<span class="nc" id="L605">                return true;</span>
            }
        }
<span class="nc bnc" id="L608" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L609">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L610" title="All 4 branches missed.">            if (line.startsWith(&quot;public &quot;) &amp;&amp; line.endsWith(&quot; clone() {&quot;)) {</span>
<span class="nc" id="L611">                return true;</span>
            }
        }
<span class="nc" id="L614">        return false;</span>
    }

    private boolean parseManualEqualsHashCode(int defLine) {
<span class="nc bnc" id="L618" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L619">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L620" title="All 6 branches missed.">            if (line.equals(&quot;public int hashCode() {&quot;) || (line.startsWith(&quot;public boolean equals(&quot;) &amp;&amp; line.endsWith(&quot;) {&quot;))) {</span>
<span class="nc" id="L621">                return true;</span>
            }
        }
<span class="nc bnc" id="L624" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L625">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L626" title="All 6 branches missed.">            if (line.equals(&quot;public int hashCode() {&quot;) || (line.startsWith(&quot;public boolean equals(&quot;) &amp;&amp; line.endsWith(&quot;) {&quot;))) {</span>
<span class="nc" id="L627">                return true;</span>
            }
        }
<span class="nc" id="L630">        return false;</span>
    }

    private boolean parseManualToStringCode(int defLine) {
<span class="nc bnc" id="L634" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L635">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">            if (line.equals(&quot;public String toString() {&quot;)) {</span>
<span class="nc" id="L637">                return true;</span>
            }
        }
<span class="nc bnc" id="L640" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L641">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (line.equals(&quot;public String toString() {&quot;)) {</span>
<span class="nc" id="L643">                return true;</span>
            }
        }
<span class="nc" id="L646">        return false;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>