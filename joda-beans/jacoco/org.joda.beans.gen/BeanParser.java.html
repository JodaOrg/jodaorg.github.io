<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda-Beans</a> &gt; <a href="index.source.html" class="el_package">org.joda.beans.gen</a> &gt; <span class="el_source">BeanParser.java</span></div><h1>BeanParser.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-present Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.beans.gen;

import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_BY_ARGS;
import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_BY_BUILDER;
import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_NONE;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Parse bean information from source file.
 * 
 * @author Stephen Colebourne
 */
class BeanParser {

    /** Start marker. */
    private static final String AUTOGENERATED_START_TEXT = &quot;AUTOGENERATED START&quot;;
    /** Start marker. */
    private static final String AUTOGENERATED_START = &quot;\t//------------------------- AUTOGENERATED START -------------------------&quot;;
    /** End marker. */
    private static final String AUTOGENERATED_END = &quot;\t//-------------------------- AUTOGENERATED END --------------------------&quot;;
    /** Pattern to find bean type. */
    // handle three comma separated generic parameters
    // handle generic parameter extends clause
    // handle extends clause with further level of generic parameters
    // handle extends clause union types without generic parameters
<span class="nc" id="L48">    private static final Pattern BEAN_TYPE = Pattern.compile(&quot;.*class +(&quot; +</span>
            &quot;([A-Z][A-Za-z0-9_]+)&quot; +
                &quot;(?:&lt;&quot; +
                    &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                    &quot;(?:[,] +&quot; +
                        &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                        &quot;(?:[,] +&quot; +
                            &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                        &quot;)?&quot; +
                    &quot;)?&quot; +
                &quot;&gt;)?&quot; +
            &quot;).*&quot;);
    /** Pattern to find super type. */
<span class="nc" id="L61">    private static final Pattern SUPER_TYPE = Pattern.compile(&quot;.*extends +(&quot; +</span>
            &quot;([A-Z][A-Za-z0-9_]+)&quot; +
                &quot;(?:&lt;&quot; +
                    &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)&quot; +
                    &quot;(?:[,] +&quot; +
                        &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)?&quot; +
                        &quot;(?:[,] +&quot; +
                            &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)?&quot; +
                        &quot;)?&quot; +
                    &quot;)?&quot; +
                &quot;&gt;)?&quot; +
            &quot;).*&quot;);
    /** Pattern to find root type. */
<span class="nc" id="L74">    private static final Pattern SUPER_IMPL_TYPE = Pattern.compile(&quot;.*implements.*[ ,]((Immutable)?Bean)([ ,{]|$).*&quot;);</span>
    /** Pattern to find serializable interface. */
<span class="nc" id="L76">    private static final Pattern SERIALIZABLE_TYPE = Pattern.compile(&quot;.*implements.*[ ,]Serializable([ ,{]|$).*&quot;);</span>
    /** The style pattern. */
<span class="nc" id="L78">    private static final Pattern STYLE_PATTERN = Pattern.compile(&quot;.*[ ,(]style[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The metaScope pattern. */
<span class="nc" id="L80">    private static final Pattern META_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]metaScope[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The builderScope pattern. */
<span class="nc" id="L82">    private static final Pattern BUILDER_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]builderScope[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The constructorScope pattern. */
<span class="nc" id="L84">    private static final Pattern CONSTRUCTOR_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]constructorScope[ ]*[=][ ]*[\&quot;]([a-zA-Z@]*)[\&quot;].*&quot;);</span>
    /** The factoryName pattern. */
<span class="nc" id="L86">    private static final Pattern FACTORY_NAME_PATTERN = Pattern.compile(&quot;.*[ ,(]factoryName[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The hierarchy pattern. */
<span class="nc" id="L88">    private static final Pattern HIERARCHY_PATTERN = Pattern.compile(&quot;.*[ ,(]hierarchy[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The cacheHashCode pattern. */
<span class="nc" id="L90">    private static final Pattern CACHE_HASH_CODE_PATTERN = Pattern.compile(&quot;.*[ ,(]cacheHashCode[ ]*[=][ ]*(true|false).*&quot;);</span>
    /** The cloneStyle pattern. */
<span class="nc" id="L92">    private static final Pattern CLONE_STYLE_PATTERN = Pattern.compile(&quot;.*[ ,(]cloneStyle[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>

    /** The validator pattern. */
<span class="nc" id="L95">    private static final Pattern VALIDATOR_PATTERN = Pattern.compile(</span>
            &quot;.*private[ ]+void[ ]+&quot; +
            &quot;([a-zA-Z][a-zA-Z0-9]*)[(][ ]*[)].*&quot;);
    /** The defaults pattern. */
<span class="nc" id="L99">    private static final Pattern DEFAULTS_PATTERN = Pattern.compile(</span>
            &quot;.*private[ ]+static[ ]+void[ ]+&quot; +
            &quot;([a-zA-Z][a-zA-Z0-9]*)[(][ ]*Builder[ ]+[a-zA-Z][a-zA-Z0-9]*[ ]*[)].*&quot;);

    /** The content to process. */
    private final File file;
    /** The content to process. */
    private final List&lt;String&gt; content;
    /** The content to process. */
    private final BeanGenConfig config;
    /** The content to process. */
    private int beanDefIndex;
    /** The start position of auto-generation. */
    private int autoStartIndex;
    /** The end position of auto-generation. */
    private int autoEndIndex;
    /** The list of property generators. */
    private List&lt;PropertyGen&gt; properties;

    /**
     * Constructor.
     * @param file  the file to process, not null
     * @param content  the content to process, not null
     */
<span class="nc" id="L123">    BeanParser(File file, List&lt;String&gt; content, BeanGenConfig config) {</span>
<span class="nc" id="L124">        this.file = file;</span>
<span class="nc" id="L125">        this.content = content;</span>
<span class="nc" id="L126">        this.config = config;</span>
<span class="nc" id="L127">    }</span>

    //-----------------------------------------------------------------------
    File getFile() {
<span class="nc" id="L131">        return file;</span>
    }

    String getFieldPrefix() {
<span class="nc" id="L135">        return config.getPrefix();</span>
    }

    BeanGenConfig getConfig() {
<span class="nc" id="L139">        return config;</span>
    }

    //-----------------------------------------------------------------------
    BeanGen parse() {
<span class="nc" id="L144">        BeanData data = new BeanData();</span>
<span class="nc" id="L145">        beanDefIndex = parseBeanDefinition();</span>
<span class="nc" id="L146">        data.getCurrentImports().addAll(parseImports(beanDefIndex));</span>
<span class="nc" id="L147">        data.setImportInsertLocation(parseImportLocation(beanDefIndex));</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (beanDefIndex &lt; 0) {</span>
<span class="nc" id="L149">            return new BeanGen(file, content, config, data);</span>
        }
<span class="nc" id="L151">        data.setBeanStyle(parseBeanStyle(beanDefIndex));</span>
<span class="nc" id="L152">        data.resolveBeanStyle(config.getDefaultStyle());</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (data.isBeanStyleValid() == false) {</span>
<span class="nc" id="L154">            throw new BeanCodeGenException(&quot;Invalid bean style: &quot; + data.getBeanStyle(), file, beanDefIndex);</span>
        }
<span class="nc" id="L156">        data.setConstructorScope(parseConstrucorScope(beanDefIndex));</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (data.isConstructorScopeValid() == false) {</span>
<span class="nc" id="L158">            throw new BeanCodeGenException(&quot;Invalid constructor scope: &quot; + data.getConstructorScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L160">        data.setBeanMetaScope(parseBeanMetaScope(beanDefIndex));</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (data.isBeanMetaScopeValid() == false) {</span>
<span class="nc" id="L162">            throw new BeanCodeGenException(&quot;Invalid meta-bean scope: &quot; + data.getBeanMetaScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L164">        data.setBeanBuilderScope(parseBeanBuilderScope(beanDefIndex));</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (data.isBeanBuilderScopeValid() == false) {</span>
<span class="nc" id="L166">            throw new BeanCodeGenException(&quot;Invalid bean builder scope: &quot; + data.getBeanBuilderScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L168">        data.setFactoryName(parseFactoryName(beanDefIndex));</span>
<span class="nc" id="L169">        data.setCacheHashCode(parseCacheHashCode(beanDefIndex));</span>
<span class="nc" id="L170">        data.setCloneStyle(parseCloneStyle(beanDefIndex));</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (data.isCloneStyleValid() == false) {</span>
<span class="nc" id="L172">            throw new BeanCodeGenException(&quot;Invalid clone style: &quot; + data.getCloneStyle(), file, beanDefIndex);</span>
        }
<span class="nc" id="L174">        data.setImmutableConstructor(parseImmutableConstructor(beanDefIndex));</span>
<span class="nc" id="L175">        data.setConstructable(parseConstructable(beanDefIndex));</span>
<span class="nc" id="L176">        data.setTypeParts(parseBeanType(beanDefIndex));</span>
<span class="nc" id="L177">        String classHeaderAfterType = classHeaderAfterType(beanDefIndex, data.getType());</span>
<span class="nc" id="L178">        data.setSuperTypeParts(parseBeanSuperType(classHeaderAfterType));</span>
<span class="nc" id="L179">        data.setSerializable(parseSerializable(classHeaderAfterType));</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (parseBeanHierarchy(beanDefIndex).equals(&quot;immutable&quot;)) {</span>
<span class="nc" id="L181">            data.setImmutable(true);</span>
<span class="nc" id="L182">            data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        } else if (data.getImmutableConstructor() == CONSTRUCTOR_NONE) {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (data.isImmutable()) {</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                if (data.isTypeFinal()) {</span>
<span class="nc" id="L186">                    data.setConstructorStyle(CONSTRUCTOR_BY_ARGS);</span>
                } else {
<span class="nc" id="L188">                    data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
                }
            } else {
<span class="nc bnc" id="L191" title="All 2 branches missed.">                if (data.isBeanStyleLight()) {</span>
<span class="nc" id="L192">                    data.setConstructorStyle(CONSTRUCTOR_BY_ARGS);</span>
                } else {
<span class="nc" id="L194">                    data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
                }
            }
        } else {
<span class="nc" id="L198">            data.setConstructorStyle(data.getImmutableConstructor());</span>
        }
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (data.isImmutable()) {</span>
<span class="nc" id="L201">            data.setImmutableValidator(parseImmutableValidator(beanDefIndex));</span>
<span class="nc" id="L202">            data.setImmutableDefaults(parseImmutableDefaults(beanDefIndex));</span>
<span class="nc" id="L203">            data.setImmutablePreBuild(parseImmutablePreBuild(beanDefIndex));</span>
<span class="nc bnc" id="L204" title="All 4 branches missed.">            if (data.isBeanStyleLight() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L205">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Light beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L208" title="All 4 branches missed.">            if (data.isBeanStyleMinimal() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L209">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Minimal beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L212" title="All 4 branches missed.">            if (data.isFactoryRequired() &amp;&amp; !data.isRootClass()) {</span>
<span class="nc" id="L213">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean has no bean superclass&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L216" title="All 4 branches missed.">            if (data.isFactoryRequired() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L217">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean is final&quot;, file, beanDefIndex);
            }
        } else {
<span class="nc bnc" id="L221" title="All 4 branches missed.">            if (data.isBeanStyleLight() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L222">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Light beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L225" title="All 4 branches missed.">            if (data.isBeanStyleMinimal() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L226">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Minimal beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L229" title="All 2 branches missed.">            if (data.isFactoryRequired()) {</span>
<span class="nc" id="L230">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean is immutable&quot;, file, beanDefIndex);
            }
        }
<span class="nc" id="L234">        properties = parseProperties(data);</span>
<span class="nc" id="L235">        autoStartIndex = parseStartAutogen();</span>
<span class="nc" id="L236">        autoEndIndex = parseEndAutogen();</span>
<span class="nc" id="L237">        data.setManualSerializationId(parseManualSerializationId(beanDefIndex));</span>
<span class="nc" id="L238">        data.setManualClone(parseManualClone(beanDefIndex));</span>
<span class="nc" id="L239">        data.setManualEqualsHashCode(parseManualEqualsHashCode(beanDefIndex));</span>
<span class="nc" id="L240">        data.setManualToStringCode(parseManualToStringCode(beanDefIndex));</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (data.isImmutable()) {</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            for (PropertyGen prop : properties) {</span>
<span class="nc bnc" id="L243" title="All 4 branches missed.">                if (prop.getData().isDerived() == false &amp;&amp; prop.getData().isFinal() == false) {</span>
<span class="nc" id="L244">                    throw new BeanCodeGenException(&quot;ImmutableBean must have final properties: &quot; +</span>
<span class="nc" id="L245">                            data.getTypeRaw() + &quot;.&quot; + prop.getData().getFieldName(),</span>
<span class="nc" id="L246">                            file, prop.getData().getLineIndex());</span>
                }
<span class="nc" id="L248">            }</span>
        } else {
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (data.getImmutableConstructor() &gt; CONSTRUCTOR_NONE) {</span>
<span class="nc" id="L251">                throw new BeanCodeGenException(&quot;Mutable beans must not specify @ImmutableConstructor: &quot; +</span>
<span class="nc" id="L252">                        data.getTypeRaw(), file, beanDefIndex);</span>
            }
<span class="nc bnc" id="L254" title="All 4 branches missed.">            if (!&quot;smart&quot;.equals(data.getConstructorScope()) &amp;&amp; !data.isBeanStyleLight()) {</span>
<span class="nc" id="L255">                throw new BeanCodeGenException(&quot;Mutable beans must not specify @BeanDefinition(constructorScope): &quot; +</span>
<span class="nc" id="L256">                                data.getTypeRaw(), file, beanDefIndex);</span>
            }
        }
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (data.isCacheHashCode()) {</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">            data.setCacheHashCode(data.isImmutable() &amp;&amp; data.isManualEqualsHashCode() == false);</span>
        }
<span class="nc" id="L262">        return new BeanGen(file, content, config, data, properties, autoStartIndex, autoEndIndex);</span>
    }

    private String classHeaderAfterType(int defLine, String fullType) {
<span class="nc" id="L266">        StringBuilder buf = new StringBuilder(128);</span>
<span class="nc" id="L267">        boolean matchedType = false;</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc" id="L269">            String line = content.get(index);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            if (matchedType == false) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                if (line.contains(fullType) == false) {</span>
<span class="nc" id="L272">                    continue;</span>
                }
<span class="nc" id="L274">                matchedType = true;</span>
<span class="nc" id="L275">                line = line.substring(line.indexOf(fullType) + fullType.length());</span>
            }
<span class="nc" id="L277">            buf.append(line).append(' ');</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (line.trim().endsWith(&quot;{&quot;)) {</span>
<span class="nc" id="L279">                break;</span>
            }
        }
<span class="nc" id="L282">        return buf.toString().trim();</span>
    }

    //-----------------------------------------------------------------------
    private int parseBeanDefinition() {
<span class="nc bnc" id="L287" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L288">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">            if (line.startsWith(&quot;@BeanDefinition&quot;)) {</span>
<span class="nc" id="L290">                return index;</span>
            }
        }
<span class="nc" id="L293">        return -1;</span>
    }

    private Set&lt;String&gt; parseImports(int defLine) {
<span class="nc bnc" id="L297" title="All 2 branches missed.">        int end = defLine &lt; 0 ? content.size() : defLine;</span>
<span class="nc" id="L298">        Set&lt;String&gt; imports = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        for (int index = 0; index &lt; end; index++) {</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">            if (content.get(index).startsWith(&quot;import &quot;)) {</span>
<span class="nc" id="L301">                String imp = content.get(index).substring(7).trim();</span>
<span class="nc" id="L302">                imp = imp.substring(0, imp.indexOf(';'));</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                if (imp.endsWith(&quot;.*&quot;) == false) {</span>
<span class="nc" id="L304">                    imports.add(imp);</span>
                }
            }
        }
<span class="nc" id="L308">        return imports;</span>
    }

    private int parseImportLocation(int defLine) {
<span class="nc bnc" id="L312" title="All 2 branches missed.">        int end = defLine &lt; 0 ? content.size() : defLine;</span>
<span class="nc" id="L313">        int location = 0;</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">        for (int index = 0; index &lt; end; index++) {</span>
<span class="nc bnc" id="L315" title="All 4 branches missed.">            if (content.get(index).startsWith(&quot;import &quot;) || content.get(index).startsWith(&quot;package &quot;)) {</span>
<span class="nc" id="L316">                location = index;</span>
            }
        }
<span class="nc" id="L319">        return location;</span>
    }

    private String parseBeanStyle(int defLine) {
<span class="nc" id="L323">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L324">        Matcher matcher = STYLE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L326">            return matcher.group(1);</span>
        }
<span class="nc" id="L328">        return &quot;smart&quot;;</span>
    }

    private String parseConstrucorScope(int defLine) {
<span class="nc" id="L332">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L333">        Matcher matcher = CONSTRUCTOR_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L335">            return matcher.group(1);</span>
        }
<span class="nc" id="L337">        return &quot;smart&quot;;</span>
    }

    private String parseBeanMetaScope(int defLine) {
<span class="nc" id="L341">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L342">        Matcher matcher = META_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L344">            return matcher.group(1);</span>
        }
<span class="nc" id="L346">        return &quot;smart&quot;;</span>
    }

    private String parseBeanBuilderScope(int defLine) {
<span class="nc" id="L350">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L351">        Matcher matcher = BUILDER_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L353">            return matcher.group(1);</span>
        }
<span class="nc" id="L355">        return &quot;smart&quot;;</span>
    }

    private String parseFactoryName(int defLine) {
<span class="nc" id="L359">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L360">        Matcher matcher = FACTORY_NAME_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L362">            return matcher.group(1);</span>
        }
<span class="nc" id="L364">        return &quot;&quot;;</span>
    }

    private String parseBeanHierarchy(int defLine) {
<span class="nc" id="L368">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L369">        Matcher matcher = HIERARCHY_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L371">            return matcher.group(1);</span>
        }
<span class="nc" id="L373">        return &quot;&quot;;</span>
    }

    private boolean parseCacheHashCode(int defLine) {
<span class="nc" id="L377">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L378">        Matcher matcher = CACHE_HASH_CODE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L380">            return Boolean.valueOf(matcher.group(1));</span>
        }
<span class="nc" id="L382">        return false;</span>
    }

    private String parseCloneStyle(int defLine) {
<span class="nc" id="L386">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L387">        Matcher matcher = CLONE_STYLE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L389">            return matcher.group(1);</span>
        }
<span class="nc" id="L391">        return &quot;smart&quot;;</span>
    }

    private boolean parseConstructable(int defLine) {
<span class="nc bnc" id="L395" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (content.get(index).contains(&quot; abstract class &quot;)) {</span>
<span class="nc" id="L397">                return false;</span>
            }
        }
<span class="nc" id="L400">        return true;</span>
    }

    private String[] parseBeanType(int defLine) {
<span class="nc" id="L404">        Matcher matcher = BEAN_TYPE.matcher(&quot;&quot;);</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc" id="L406">            String line = content.get(index);</span>
<span class="nc" id="L407">            matcher.reset(line);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if (matcher.matches()) {</span>
<span class="nc" id="L409">                String startStr = line.substring(0, matcher.start(1));</span>
<span class="nc bnc" id="L410" title="All 4 branches missed.">                String fnl = startStr.contains(&quot; final &quot;) || startStr.startsWith(&quot;final &quot;) ? &quot;final&quot; : null;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                String scope = startStr.contains(&quot;public &quot;) ? &quot;public&quot; : &quot;package&quot;;</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                scope = startStr.contains(&quot;protected &quot;) ? &quot;protected&quot; : scope;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                scope = startStr.contains(&quot;private &quot;) ? &quot;private&quot; : scope;</span>
<span class="nc" id="L414">                return new String[] {fnl, scope, matcher.group(1), matcher.group(2), matcher.group(3),</span>
<span class="nc" id="L415">                        matcher.group(4), matcher.group(5), matcher.group(6), matcher.group(7), matcher.group(8)};</span>
            }
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (line.contains(AUTOGENERATED_START_TEXT)) {</span>
<span class="nc" id="L418">                break;</span>
            }
        }
<span class="nc" id="L421">        throw new BeanCodeGenException(&quot;Unable to locate bean class name&quot;, file, beanDefIndex);</span>
    }

    private String[] parseBeanSuperType(String classHeaderAfterType) {
        // this uses classHeaderAfterType as extends has two meanings in class headers
        // search for implements
<span class="nc" id="L427">        Matcher matcherImplements = SUPER_IMPL_TYPE.matcher(classHeaderAfterType);</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">        if (matcherImplements.matches()) {</span>
<span class="nc" id="L429">            return new String[] {matcherImplements.group(1)};</span>
        }
        // search for extends
<span class="nc" id="L432">        Matcher matcherExtends = SUPER_TYPE.matcher(classHeaderAfterType);</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (matcherExtends.matches()) {</span>
<span class="nc" id="L434">            return new String[] {matcherExtends.group(1), matcherExtends.group(2), matcherExtends.group(3),</span>
<span class="nc" id="L435">                    matcherExtends.group(4), matcherExtends.group(5)};</span>
        }
<span class="nc" id="L437">        throw new BeanCodeGenException(&quot;Unable to locate bean superclass&quot;, file, beanDefIndex);</span>
    }

    private boolean parseSerializable(String classHeaderAfterType) {
<span class="nc" id="L441">        return SERIALIZABLE_TYPE.matcher(classHeaderAfterType).matches();</span>
    }

    private boolean parseManualSerializationId(int defLine) {
<span class="nc bnc" id="L445" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (content.get(index).trim().startsWith(&quot;private static final long serialVersionUID&quot;)) {</span>
<span class="nc" id="L447">                return true;</span>
            }
        }
<span class="nc" id="L450">        return false;</span>
    }

    private int parseImmutableConstructor(int defLine) {
<span class="nc" id="L454">        int found = CONSTRUCTOR_NONE;</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableConstructor&quot;)) {</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (found &gt; 0) {</span>
<span class="nc" id="L458">                    throw new BeanCodeGenException(&quot;Only one @ImmutableConstructor may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L460">                found = CONSTRUCTOR_BY_ARGS;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L462">                    String nextLine = content.get(index + 1);</span>
<span class="nc bnc" id="L463" title="All 4 branches missed.">                    if (nextLine.contains(&quot;Builder &quot;) || nextLine.contains(&quot;Builder&lt;&quot;)) {</span>
<span class="nc" id="L464">                        found = CONSTRUCTOR_BY_BUILDER;</span>
                    }
                }
            }
        }
<span class="nc" id="L469">        return found;</span>
    }

    private String parseImmutableValidator(int defLine) {
<span class="nc" id="L473">        boolean found = false;</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableValidator&quot;)) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L477">                    throw new BeanCodeGenException(&quot;Only one @ImmutableValidator may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L479">                found = true;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L481">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L482">                    Matcher matcher = VALIDATOR_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L484">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L486">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutableValidator method must be private void and no-args&quot;, file, index + 1);
                }
            }
        }
<span class="nc" id="L491">        return null;</span>
    }

    private String parseImmutableDefaults(int defLine) {
<span class="nc" id="L495">        boolean found = false;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableDefaults&quot;)) {</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L499">                    throw new BeanCodeGenException(&quot;Only one @ImmutableDefaults may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L501">                found = true;</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L503">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L504">                    Matcher matcher = DEFAULTS_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L506">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L508">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutableDefaults method must be private static void and have one argument of type 'Builder'&quot;,
                        file, index + 1);
                }
            }
        }
<span class="nc" id="L514">        return null;</span>
    }

    private String parseImmutablePreBuild(int defLine) {
<span class="nc" id="L518">        boolean found = false;</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutablePreBuild&quot;)) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L522">                    throw new BeanCodeGenException(&quot;Only one @ImmutablePreBuild may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L524">                found = true;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L526">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L527">                    Matcher matcher = DEFAULTS_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L529">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L531">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutablePreBuild method must be private static void and have one argument of type 'Builder'&quot;,
                        file, index + 1);
                }
            }
        }
<span class="nc" id="L537">        return null;</span>
    }

    private List&lt;PropertyGen&gt; parseProperties(BeanData data) {
<span class="nc" id="L541">        List&lt;PropertyGen&gt; props = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L543">            String line = content.get(index).trim();</span>
<span class="nc" id="L544">            PropertyParser parser = new PropertyParser(this);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">            if (line.startsWith(&quot;@PropertyDefinition&quot;)) {</span>
<span class="nc" id="L546">                PropertyGen prop = parser.parse(data, content, index);</span>
<span class="nc" id="L547">                props.add(prop);</span>
<span class="nc" id="L548">                data.getProperties().add(prop.getData());</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">            } else if (line.startsWith(&quot;@DerivedProperty&quot;)) {</span>
<span class="nc" id="L550">                PropertyGen prop = parser.parseDerived(data, content, index);</span>
<span class="nc" id="L551">                props.add(prop);</span>
<span class="nc" id="L552">                data.getProperties().add(prop.getData());</span>
            }
        }
<span class="nc" id="L555">        return props;</span>
    }

    private int parseStartAutogen() {
<span class="nc bnc" id="L559" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L560">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">            if (line.contains(&quot; AUTOGENERATED START &quot;)) {</span>
<span class="nc" id="L562">                content.set(index, AUTOGENERATED_START);</span>
<span class="nc" id="L563">                return index;</span>
            }
        }
<span class="nc bnc" id="L566" title="All 2 branches missed.">        for (int index = content.size() - 1; index &gt;= 0; index--) {</span>
<span class="nc" id="L567">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (line.equals(&quot;}&quot;)) {</span>
<span class="nc" id="L569">                content.add(index, AUTOGENERATED_START);</span>
<span class="nc" id="L570">                return index;</span>
            }
<span class="nc bnc" id="L572" title="All 2 branches missed.">            if (line.length() &gt; 0) {</span>
<span class="nc" id="L573">                break;</span>
            }
        }
<span class="nc" id="L576">        throw new BeanCodeGenException(&quot;Unable to locate start autogeneration point&quot;, file, beanDefIndex);</span>
    }

    private int parseEndAutogen() {
<span class="nc bnc" id="L580" title="All 2 branches missed.">        for (int index = autoStartIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L581">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (line.contains(&quot; AUTOGENERATED END &quot;)) {</span>
<span class="nc" id="L583">                content.set(index, AUTOGENERATED_END);</span>
<span class="nc" id="L584">                return index;</span>
            }
        }
<span class="nc" id="L587">        content.add(autoStartIndex + 1, AUTOGENERATED_END);</span>
<span class="nc" id="L588">        return autoStartIndex + 1;</span>
    }

    private boolean parseManualClone(int defLine) {
<span class="nc bnc" id="L592" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L593">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L594" title="All 4 branches missed.">            if (line.startsWith(&quot;public &quot;) &amp;&amp; line.endsWith(&quot; clone() {&quot;)) {</span>
<span class="nc" id="L595">                return true;</span>
            }
        }
<span class="nc bnc" id="L598" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L599">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L600" title="All 4 branches missed.">            if (line.startsWith(&quot;public &quot;) &amp;&amp; line.endsWith(&quot; clone() {&quot;)) {</span>
<span class="nc" id="L601">                return true;</span>
            }
        }
<span class="nc" id="L604">        return false;</span>
    }

    private boolean parseManualEqualsHashCode(int defLine) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L609">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L610" title="All 6 branches missed.">            if (line.equals(&quot;public int hashCode() {&quot;) || (line.startsWith(&quot;public boolean equals(&quot;) &amp;&amp; line.endsWith(&quot;) {&quot;))) {</span>
<span class="nc" id="L611">                return true;</span>
            }
        }
<span class="nc bnc" id="L614" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L615">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L616" title="All 6 branches missed.">            if (line.equals(&quot;public int hashCode() {&quot;) || (line.startsWith(&quot;public boolean equals(&quot;) &amp;&amp; line.endsWith(&quot;) {&quot;))) {</span>
<span class="nc" id="L617">                return true;</span>
            }
        }
<span class="nc" id="L620">        return false;</span>
    }

    private boolean parseManualToStringCode(int defLine) {
<span class="nc bnc" id="L624" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L625">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">            if (line.equals(&quot;public String toString() {&quot;)) {</span>
<span class="nc" id="L627">                return true;</span>
            }
        }
<span class="nc bnc" id="L630" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L631">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (line.equals(&quot;public String toString() {&quot;)) {</span>
<span class="nc" id="L633">                return true;</span>
            }
        }
<span class="nc" id="L636">        return false;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>