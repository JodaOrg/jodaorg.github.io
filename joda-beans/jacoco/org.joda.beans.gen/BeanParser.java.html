<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda-Beans</a> &gt; <a href="index.source.html" class="el_package">org.joda.beans.gen</a> &gt; <span class="el_source">BeanParser.java</span></div><h1>BeanParser.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-present Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.beans.gen;

import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_BY_ARGS;
import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_BY_BUILDER;
import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_NONE;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Parse bean information from source file.
 * 
 * @author Stephen Colebourne
 */
class BeanParser {

    /** Start marker. */
    private static final String AUTOGENERATED_START_TEXT = &quot;AUTOGENERATED START&quot;;
    /** Start marker. */
    private static final String AUTOGENERATED_START = &quot;\t//------------------------- AUTOGENERATED START -------------------------&quot;;
    /** End marker. */
    private static final String AUTOGENERATED_END = &quot;\t//-------------------------- AUTOGENERATED END --------------------------&quot;;
    /** Pattern to find bean type. */
    // handle three comma separated generic parameters
    // handle generic parameter extends clause
    // handle extends clause with further level of generic parameters
    // handle extends clause union types without generic parameters
<span class="nc" id="L48">    private static final Pattern BEAN_TYPE = Pattern.compile(&quot;.*class +(&quot; +</span>
            &quot;([A-Z][A-Za-z0-9_]+)&quot; +
                &quot;(?:&lt;&quot; +
                    &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                    &quot;(?:[,] +&quot; +
                        &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                        &quot;(?:[,] +&quot; +
                            &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                        &quot;)?&quot; +
                    &quot;)?&quot; +
                &quot;&gt;)?&quot; +
            &quot;).*&quot;);
    /** Pattern to find super type. */
<span class="nc" id="L61">    private static final Pattern SUPER_TYPE = Pattern.compile(&quot;.*extends +(&quot; +</span>
            &quot;([A-Z][A-Za-z0-9_]+)&quot; +
                &quot;(?:&lt;&quot; +
                    &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)&quot; +
                    &quot;(?:[,] +&quot; +
                        &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)?&quot; +
                        &quot;(?:[,] +&quot; +
                            &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)?&quot; +
                        &quot;)?&quot; +
                    &quot;)?&quot; +
                &quot;&gt;)?&quot; +
            &quot;).*&quot;);
    /** Pattern to find root type. */
<span class="nc" id="L74">    private static final Pattern SUPER_IMPL_TYPE = Pattern.compile(&quot;.*implements.*[ ,]((Immutable)?Bean)([ ,{]|$).*&quot;);</span>
    /** Pattern to find serializable interface. */
<span class="nc" id="L76">    private static final Pattern SERIALIZABLE_TYPE = Pattern.compile(&quot;.*implements.*[ ,]Serializable([ ,{]|$).*&quot;);</span>
    /** The style pattern. */
<span class="nc" id="L78">    private static final Pattern STYLE_PATTERN = Pattern.compile(&quot;.*[ ,(]style[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The metaScope pattern. */
<span class="nc" id="L80">    private static final Pattern META_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]metaScope[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The builderScope pattern. */
<span class="nc" id="L82">    private static final Pattern BUILDER_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]builderScope[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The constructorScope pattern. */
<span class="nc" id="L84">    private static final Pattern CONSTRUCTOR_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]constructorScope[ ]*[=][ ]*[\&quot;]([a-zA-Z@]*)[\&quot;].*&quot;);</span>
    /** The factoryName pattern. */
<span class="nc" id="L86">    private static final Pattern FACTORY_NAME_PATTERN = Pattern.compile(&quot;.*[ ,(]factoryName[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The hierarchy pattern. */
<span class="nc" id="L88">    private static final Pattern HIERARCHY_PATTERN = Pattern.compile(&quot;.*[ ,(]hierarchy[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The cacheHashCode pattern. */
<span class="nc" id="L90">    private static final Pattern CACHE_HASH_CODE_PATTERN = Pattern.compile(&quot;.*[ ,(]cacheHashCode[ ]*[=][ ]*(true|false).*&quot;);</span>
    /** The cloneStyle pattern. */
<span class="nc" id="L92">    private static final Pattern CLONE_STYLE_PATTERN = Pattern.compile(&quot;.*[ ,(]cloneStyle[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>

    /** The validator pattern. */
<span class="nc" id="L95">    private static final Pattern VALIDATOR_PATTERN = Pattern.compile(</span>
            &quot;.*private[ ]+void[ ]+&quot; +
            &quot;([a-zA-Z][a-zA-Z0-9]*)[(][ ]*[)].*&quot;);
    /** The defaults pattern. */
<span class="nc" id="L99">    private static final Pattern DEFAULTS_PATTERN = Pattern.compile(</span>
            &quot;.*private[ ]+static[ ]+void[ ]+&quot; +
            &quot;([a-zA-Z][a-zA-Z0-9]*)[(][ ]*Builder[ ]+[a-zA-Z][a-zA-Z0-9]*[ ]*[)].*&quot;);

    /** The content to process. */
    private final File file;
    /** The content to process. */
    private final List&lt;String&gt; content;
    /** The content to process. */
    private final BeanGenConfig config;
    /** The content to process. */
    private int beanDefIndex;
    /** The start position of auto-generation. */
    private int autoStartIndex;
    /** The end position of auto-generation. */
    private int autoEndIndex;
    /** The list of property generators. */
    private List&lt;PropertyGen&gt; properties;

    /**
     * Constructor.
     * @param file  the file to process, not null
     * @param content  the content to process, not null
     */
<span class="nc" id="L123">    BeanParser(File file, List&lt;String&gt; content, BeanGenConfig config) {</span>
<span class="nc" id="L124">        this.file = file;</span>
<span class="nc" id="L125">        this.content = content;</span>
<span class="nc" id="L126">        this.config = config;</span>
<span class="nc" id="L127">    }</span>

    //-----------------------------------------------------------------------
    File getFile() {
<span class="nc" id="L131">        return file;</span>
    }

    String getFieldPrefix() {
<span class="nc" id="L135">        return config.getPrefix();</span>
    }

    BeanGenConfig getConfig() {
<span class="nc" id="L139">        return config;</span>
    }

    //-----------------------------------------------------------------------
    BeanGen parse() {
<span class="nc" id="L144">        BeanData data = new BeanData();</span>
<span class="nc" id="L145">        beanDefIndex = parseBeanDefinition();</span>
<span class="nc" id="L146">        data.getCurrentImports().addAll(parseImports(beanDefIndex));</span>
<span class="nc" id="L147">        data.setImportInsertLocation(parseImportLocation(beanDefIndex));</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (beanDefIndex &lt; 0) {</span>
<span class="nc" id="L149">            return new BeanGen(file, content, config, data);</span>
        }
<span class="nc" id="L151">        data.setBeanStyle(parseBeanStyle(beanDefIndex));</span>
<span class="nc" id="L152">        data.resolveBeanStyle(config.getDefaultStyle());</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (data.isBeanStyleValid() == false) {</span>
<span class="nc" id="L154">            throw new BeanCodeGenException(&quot;Invalid bean style: &quot; + data.getBeanStyle(), file, beanDefIndex);</span>
        }
<span class="nc" id="L156">        data.setConstructorScope(parseConstrucorScope(beanDefIndex));</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (data.isConstructorScopeValid() == false) {</span>
<span class="nc" id="L158">            throw new BeanCodeGenException(&quot;Invalid constructor scope: &quot; + data.getConstructorScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L160">        data.setBeanMetaScope(parseBeanMetaScope(beanDefIndex));</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (data.isBeanMetaScopeValid() == false) {</span>
<span class="nc" id="L162">            throw new BeanCodeGenException(&quot;Invalid meta-bean scope: &quot; + data.getBeanMetaScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L164">        data.setBeanBuilderScope(parseBeanBuilderScope(beanDefIndex));</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (data.isBeanBuilderScopeValid() == false) {</span>
<span class="nc" id="L166">            throw new BeanCodeGenException(&quot;Invalid bean builder scope: &quot; + data.getBeanBuilderScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L168">        data.setFactoryName(parseFactoryName(beanDefIndex));</span>
<span class="nc" id="L169">        data.setCacheHashCode(parseCacheHashCode(beanDefIndex));</span>
<span class="nc" id="L170">        data.setCloneStyle(parseCloneStyle(beanDefIndex));</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (data.isCloneStyleValid() == false) {</span>
<span class="nc" id="L172">            throw new BeanCodeGenException(&quot;Invalid clone style: &quot; + data.getCloneStyle(), file, beanDefIndex);</span>
        }
<span class="nc" id="L174">        data.setImmutableConstructor(parseImmutableConstructor(beanDefIndex));</span>
<span class="nc" id="L175">        data.setConstructable(parseConstructable(beanDefIndex));</span>
<span class="nc" id="L176">        data.setTypeParts(parseBeanType(beanDefIndex));</span>
<span class="nc" id="L177">        data.setSuperTypeParts(parseBeanSuperType(beanDefIndex, data.getType()));</span>
<span class="nc" id="L178">        data.setSerializable(parseSerializable(beanDefIndex));</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (parseBeanHierarchy(beanDefIndex).equals(&quot;immutable&quot;)) {</span>
<span class="nc" id="L180">            data.setImmutable(true);</span>
<span class="nc" id="L181">            data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        } else if (data.getImmutableConstructor() == CONSTRUCTOR_NONE) {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            if (data.isImmutable()) {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">                if (data.isTypeFinal()) {</span>
<span class="nc" id="L185">                    data.setConstructorStyle(CONSTRUCTOR_BY_ARGS);</span>
                } else {
<span class="nc" id="L187">                    data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
                }
            } else {
<span class="nc bnc" id="L190" title="All 2 branches missed.">                if (data.isBeanStyleLight()) {</span>
<span class="nc" id="L191">                    data.setConstructorStyle(CONSTRUCTOR_BY_ARGS);</span>
                } else {
<span class="nc" id="L193">                    data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
                }
            }
        } else {
<span class="nc" id="L197">            data.setConstructorStyle(data.getImmutableConstructor());</span>
        }
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (data.isImmutable()) {</span>
<span class="nc" id="L200">            data.setImmutableValidator(parseImmutableValidator(beanDefIndex));</span>
<span class="nc" id="L201">            data.setImmutableDefaults(parseImmutableDefaults(beanDefIndex));</span>
<span class="nc" id="L202">            data.setImmutablePreBuild(parseImmutablePreBuild(beanDefIndex));</span>
<span class="nc bnc" id="L203" title="All 4 branches missed.">            if (data.isBeanStyleLight() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L204">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Light beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L207" title="All 4 branches missed.">            if (data.isBeanStyleMinimal() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L208">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Minimal beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L211" title="All 4 branches missed.">            if (data.isFactoryRequired() &amp;&amp; !data.isRootClass()) {</span>
<span class="nc" id="L212">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean has no bean superclass&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L215" title="All 4 branches missed.">            if (data.isFactoryRequired() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L216">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean is final&quot;, file, beanDefIndex);
            }
        } else {
<span class="nc bnc" id="L220" title="All 4 branches missed.">            if (data.isBeanStyleLight() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L221">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Light beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L224" title="All 4 branches missed.">            if (data.isBeanStyleMinimal() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L225">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Minimal beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L228" title="All 2 branches missed.">            if (data.isFactoryRequired()) {</span>
<span class="nc" id="L229">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean is immutable&quot;, file, beanDefIndex);
            }
        }
<span class="nc" id="L233">        properties = parseProperties(data);</span>
<span class="nc" id="L234">        autoStartIndex = parseStartAutogen();</span>
<span class="nc" id="L235">        autoEndIndex = parseEndAutogen();</span>
<span class="nc" id="L236">        data.setManualSerializationId(parseManualSerializationId(beanDefIndex));</span>
<span class="nc" id="L237">        data.setManualClone(parseManualClone(beanDefIndex));</span>
<span class="nc" id="L238">        data.setManualEqualsHashCode(parseManualEqualsHashCode(beanDefIndex));</span>
<span class="nc" id="L239">        data.setManualToStringCode(parseManualToStringCode(beanDefIndex));</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (data.isImmutable()) {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            for (PropertyGen prop : properties) {</span>
<span class="nc bnc" id="L242" title="All 4 branches missed.">                if (prop.getData().isDerived() == false &amp;&amp; prop.getData().isFinal() == false) {</span>
<span class="nc" id="L243">                    throw new BeanCodeGenException(&quot;ImmutableBean must have final properties: &quot; +</span>
<span class="nc" id="L244">                            data.getTypeRaw() + &quot;.&quot; + prop.getData().getFieldName(),</span>
<span class="nc" id="L245">                            file, prop.getData().getLineIndex());</span>
                }
<span class="nc" id="L247">            }</span>
        } else {
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (data.getImmutableConstructor() &gt; CONSTRUCTOR_NONE) {</span>
<span class="nc" id="L250">                throw new BeanCodeGenException(&quot;Mutable beans must not specify @ImmutableConstructor: &quot; +</span>
<span class="nc" id="L251">                        data.getTypeRaw(), file, beanDefIndex);</span>
            }
<span class="nc bnc" id="L253" title="All 4 branches missed.">            if (!&quot;smart&quot;.equals(data.getConstructorScope()) &amp;&amp; !data.isBeanStyleLight()) {</span>
<span class="nc" id="L254">                throw new BeanCodeGenException(&quot;Mutable beans must not specify @BeanDefinition(constructorScope): &quot; +</span>
<span class="nc" id="L255">                                data.getTypeRaw(), file, beanDefIndex);</span>
            }
        }
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (data.isCacheHashCode()) {</span>
<span class="nc bnc" id="L259" title="All 4 branches missed.">            data.setCacheHashCode(data.isImmutable() &amp;&amp; data.isManualEqualsHashCode() == false);</span>
        }
<span class="nc" id="L261">        return new BeanGen(file, content, config, data, properties, autoStartIndex, autoEndIndex);</span>
    }

    //-----------------------------------------------------------------------
    private int parseBeanDefinition() {
<span class="nc bnc" id="L266" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L267">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (line.startsWith(&quot;@BeanDefinition&quot;)) {</span>
<span class="nc" id="L269">                return index;</span>
            }
        }
<span class="nc" id="L272">        return -1;</span>
    }

    private Set&lt;String&gt; parseImports(int defLine) {
<span class="nc bnc" id="L276" title="All 2 branches missed.">        int end = defLine &lt; 0 ? content.size() : defLine;</span>
<span class="nc" id="L277">        Set&lt;String&gt; imports = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        for (int index = 0; index &lt; end; index++) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (content.get(index).startsWith(&quot;import &quot;)) {</span>
<span class="nc" id="L280">                String imp = content.get(index).substring(7).trim();</span>
<span class="nc" id="L281">                imp = imp.substring(0, imp.indexOf(';'));</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                if (imp.endsWith(&quot;.*&quot;) == false) {</span>
<span class="nc" id="L283">                    imports.add(imp);</span>
                }
            }
        }
<span class="nc" id="L287">        return imports;</span>
    }

    private int parseImportLocation(int defLine) {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        int end = defLine &lt; 0 ? content.size() : defLine;</span>
<span class="nc" id="L292">        int location = 0;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        for (int index = 0; index &lt; end; index++) {</span>
<span class="nc bnc" id="L294" title="All 4 branches missed.">            if (content.get(index).startsWith(&quot;import &quot;) || content.get(index).startsWith(&quot;package &quot;)) {</span>
<span class="nc" id="L295">                location = index;</span>
            }
        }
<span class="nc" id="L298">        return location;</span>
    }

    private String parseBeanStyle(int defLine) {
<span class="nc" id="L302">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L303">        Matcher matcher = STYLE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L305">            return matcher.group(1);</span>
        }
<span class="nc" id="L307">        return &quot;smart&quot;;</span>
    }

    private String parseConstrucorScope(int defLine) {
<span class="nc" id="L311">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L312">        Matcher matcher = CONSTRUCTOR_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L314">            return matcher.group(1);</span>
        }
<span class="nc" id="L316">        return &quot;smart&quot;;</span>
    }

    private String parseBeanMetaScope(int defLine) {
<span class="nc" id="L320">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L321">        Matcher matcher = META_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L323">            return matcher.group(1);</span>
        }
<span class="nc" id="L325">        return &quot;smart&quot;;</span>
    }

    private String parseBeanBuilderScope(int defLine) {
<span class="nc" id="L329">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L330">        Matcher matcher = BUILDER_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L332">            return matcher.group(1);</span>
        }
<span class="nc" id="L334">        return &quot;smart&quot;;</span>
    }

    private String parseFactoryName(int defLine) {
<span class="nc" id="L338">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L339">        Matcher matcher = FACTORY_NAME_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L341">            return matcher.group(1);</span>
        }
<span class="nc" id="L343">        return &quot;&quot;;</span>
    }

    private String parseBeanHierarchy(int defLine) {
<span class="nc" id="L347">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L348">        Matcher matcher = HIERARCHY_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L350">            return matcher.group(1);</span>
        }
<span class="nc" id="L352">        return &quot;&quot;;</span>
    }

    private boolean parseCacheHashCode(int defLine) {
<span class="nc" id="L356">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L357">        Matcher matcher = CACHE_HASH_CODE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L359">            return Boolean.valueOf(matcher.group(1));</span>
        }
<span class="nc" id="L361">        return false;</span>
    }

    private String parseCloneStyle(int defLine) {
<span class="nc" id="L365">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L366">        Matcher matcher = CLONE_STYLE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L368">            return matcher.group(1);</span>
        }
<span class="nc" id="L370">        return &quot;smart&quot;;</span>
    }

    private boolean parseConstructable(int defLine) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            if (content.get(index).contains(&quot; abstract class &quot;)) {</span>
<span class="nc" id="L376">                return false;</span>
            }
        }
<span class="nc" id="L379">        return true;</span>
    }

    private String[] parseBeanType(int defLine) {
<span class="nc" id="L383">        Matcher matcher = BEAN_TYPE.matcher(&quot;&quot;);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc" id="L385">            String line = content.get(index);</span>
<span class="nc" id="L386">            matcher.reset(line);</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (matcher.matches()) {</span>
<span class="nc" id="L388">                String startStr = line.substring(0, matcher.start(1));</span>
<span class="nc bnc" id="L389" title="All 4 branches missed.">                String fnl = startStr.contains(&quot; final &quot;) || startStr.startsWith(&quot;final &quot;) ? &quot;final&quot; : null;</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                String scope = startStr.contains(&quot;public &quot;) ? &quot;public&quot; : &quot;package&quot;;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">                scope = startStr.contains(&quot;protected &quot;) ? &quot;protected&quot; : scope;</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                scope = startStr.contains(&quot;private &quot;) ? &quot;private&quot; : scope;</span>
<span class="nc" id="L393">                return new String[] {fnl, scope, matcher.group(1), matcher.group(2), matcher.group(3),</span>
<span class="nc" id="L394">                        matcher.group(4), matcher.group(5), matcher.group(6), matcher.group(7), matcher.group(8)};</span>
            }
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (line.contains(AUTOGENERATED_START_TEXT)) {</span>
<span class="nc" id="L397">                break;</span>
            }
        }
<span class="nc" id="L400">        throw new BeanCodeGenException(&quot;Unable to locate bean class name&quot;, file, beanDefIndex);</span>
    }

    private String[] parseBeanSuperType(int defLine, String fullType) {
        // need to start searching beyond the full type to avoid 'extends' having two meanings
        // hence use of fullType
        // search for implements
<span class="nc" id="L407">        Matcher matcherImplements = SUPER_IMPL_TYPE.matcher(&quot;&quot;);</span>
<span class="nc" id="L408">        boolean matchedType = false;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc" id="L410">            String line = content.get(index);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (matchedType == false) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                if (line.contains(fullType) == false) {</span>
<span class="nc" id="L413">                    continue;</span>
                }
<span class="nc" id="L415">                matchedType = true;</span>
<span class="nc" id="L416">                line = line.substring(line.indexOf(fullType) + fullType.length());</span>
            }
<span class="nc" id="L418">            matcherImplements.reset(line);</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (matcherImplements.matches()) {</span>
<span class="nc" id="L420">                return new String[] {matcherImplements.group(1)};</span>
            }
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (line.contains(AUTOGENERATED_START_TEXT)) {</span>
<span class="nc" id="L423">                break;</span>
            }
        }
        // search for extends
<span class="nc" id="L427">        Matcher matcherExtends = SUPER_TYPE.matcher(&quot;&quot;);</span>
<span class="nc" id="L428">        matchedType = false;</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc" id="L430">            String line = content.get(index);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">            if (matchedType == false) {</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                if (line.contains(fullType) == false) {</span>
<span class="nc" id="L433">                    continue;</span>
                }
<span class="nc" id="L435">                matchedType = true;</span>
<span class="nc" id="L436">                line = line.substring(line.indexOf(fullType) + fullType.length());</span>
            }
<span class="nc" id="L438">            matcherExtends.reset(line);</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            if (matcherExtends.matches()) {</span>
<span class="nc" id="L440">                return new String[] {matcherExtends.group(1), matcherExtends.group(2), matcherExtends.group(3),</span>
<span class="nc" id="L441">                        matcherExtends.group(4), matcherExtends.group(5)};</span>
            }
<span class="nc bnc" id="L443" title="All 2 branches missed.">            if (line.contains(AUTOGENERATED_START_TEXT)) {</span>
<span class="nc" id="L444">                break;</span>
            }
        }
<span class="nc" id="L447">        throw new BeanCodeGenException(&quot;Unable to locate bean superclass&quot;, file, beanDefIndex);</span>
    }

    private boolean parseSerializable(int defLine) {
<span class="nc bnc" id="L451" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (SERIALIZABLE_TYPE.matcher(content.get(index)).matches()) {</span>
<span class="nc" id="L453">                return true;</span>
            }
        }
<span class="nc" id="L456">        return false;</span>
    }

    private boolean parseManualSerializationId(int defLine) {
<span class="nc bnc" id="L460" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            if (content.get(index).trim().startsWith(&quot;private static final long serialVersionUID&quot;)) {</span>
<span class="nc" id="L462">                return true;</span>
            }
        }
<span class="nc" id="L465">        return false;</span>
    }

    private int parseImmutableConstructor(int defLine) {
<span class="nc" id="L469">        int found = CONSTRUCTOR_NONE;</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableConstructor&quot;)) {</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (found &gt; 0) {</span>
<span class="nc" id="L473">                    throw new BeanCodeGenException(&quot;Only one @ImmutableConstructor may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L475">                found = CONSTRUCTOR_BY_ARGS;</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L477">                    String nextLine = content.get(index + 1);</span>
<span class="nc bnc" id="L478" title="All 4 branches missed.">                    if (nextLine.contains(&quot;Builder &quot;) || nextLine.contains(&quot;Builder&lt;&quot;)) {</span>
<span class="nc" id="L479">                        found = CONSTRUCTOR_BY_BUILDER;</span>
                    }
                }
            }
        }
<span class="nc" id="L484">        return found;</span>
    }

    private String parseImmutableValidator(int defLine) {
<span class="nc" id="L488">        boolean found = false;</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableValidator&quot;)) {</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L492">                    throw new BeanCodeGenException(&quot;Only one @ImmutableValidator may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L494">                found = true;</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L496">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L497">                    Matcher matcher = VALIDATOR_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L499">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L501">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutableValidator method must be private void and no-args&quot;, file, index + 1);
                }
            }
        }
<span class="nc" id="L506">        return null;</span>
    }

    private String parseImmutableDefaults(int defLine) {
<span class="nc" id="L510">        boolean found = false;</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableDefaults&quot;)) {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L514">                    throw new BeanCodeGenException(&quot;Only one @ImmutableDefaults may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L516">                found = true;</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L518">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L519">                    Matcher matcher = DEFAULTS_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L521">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L523">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutableDefaults method must be private static void and have one argument of type 'Builder'&quot;,
                        file, index + 1);
                }
            }
        }
<span class="nc" id="L529">        return null;</span>
    }

    private String parseImmutablePreBuild(int defLine) {
<span class="nc" id="L533">        boolean found = false;</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutablePreBuild&quot;)) {</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L537">                    throw new BeanCodeGenException(&quot;Only one @ImmutablePreBuild may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L539">                found = true;</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L541">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L542">                    Matcher matcher = DEFAULTS_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L544">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L546">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutablePreBuild method must be private static void and have one argument of type 'Builder'&quot;,
                        file, index + 1);
                }
            }
        }
<span class="nc" id="L552">        return null;</span>
    }

    private List&lt;PropertyGen&gt; parseProperties(BeanData data) {
<span class="nc" id="L556">        List&lt;PropertyGen&gt; props = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L558">            String line = content.get(index).trim();</span>
<span class="nc" id="L559">            PropertyParser parser = new PropertyParser(this);</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">            if (line.startsWith(&quot;@PropertyDefinition&quot;)) {</span>
<span class="nc" id="L561">                PropertyGen prop = parser.parse(data, content, index);</span>
<span class="nc" id="L562">                props.add(prop);</span>
<span class="nc" id="L563">                data.getProperties().add(prop.getData());</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">            } else if (line.startsWith(&quot;@DerivedProperty&quot;)) {</span>
<span class="nc" id="L565">                PropertyGen prop = parser.parseDerived(data, content, index);</span>
<span class="nc" id="L566">                props.add(prop);</span>
<span class="nc" id="L567">                data.getProperties().add(prop.getData());</span>
            }
        }
<span class="nc" id="L570">        return props;</span>
    }

    private int parseStartAutogen() {
<span class="nc bnc" id="L574" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L575">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">            if (line.contains(&quot; AUTOGENERATED START &quot;)) {</span>
<span class="nc" id="L577">                content.set(index, AUTOGENERATED_START);</span>
<span class="nc" id="L578">                return index;</span>
            }
        }
<span class="nc bnc" id="L581" title="All 2 branches missed.">        for (int index = content.size() - 1; index &gt;= 0; index--) {</span>
<span class="nc" id="L582">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (line.equals(&quot;}&quot;)) {</span>
<span class="nc" id="L584">                content.add(index, AUTOGENERATED_START);</span>
<span class="nc" id="L585">                return index;</span>
            }
<span class="nc bnc" id="L587" title="All 2 branches missed.">            if (line.length() &gt; 0) {</span>
<span class="nc" id="L588">                break;</span>
            }
        }
<span class="nc" id="L591">        throw new BeanCodeGenException(&quot;Unable to locate start autogeneration point&quot;, file, beanDefIndex);</span>
    }

    private int parseEndAutogen() {
<span class="nc bnc" id="L595" title="All 2 branches missed.">        for (int index = autoStartIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L596">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">            if (line.contains(&quot; AUTOGENERATED END &quot;)) {</span>
<span class="nc" id="L598">                content.set(index, AUTOGENERATED_END);</span>
<span class="nc" id="L599">                return index;</span>
            }
        }
<span class="nc" id="L602">        content.add(autoStartIndex + 1, AUTOGENERATED_END);</span>
<span class="nc" id="L603">        return autoStartIndex + 1;</span>
    }

    private boolean parseManualClone(int defLine) {
<span class="nc bnc" id="L607" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L608">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L609" title="All 4 branches missed.">            if (line.startsWith(&quot;public &quot;) &amp;&amp; line.endsWith(&quot; clone() {&quot;)) {</span>
<span class="nc" id="L610">                return true;</span>
            }
        }
<span class="nc bnc" id="L613" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L614">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L615" title="All 4 branches missed.">            if (line.startsWith(&quot;public &quot;) &amp;&amp; line.endsWith(&quot; clone() {&quot;)) {</span>
<span class="nc" id="L616">                return true;</span>
            }
        }
<span class="nc" id="L619">        return false;</span>
    }

    private boolean parseManualEqualsHashCode(int defLine) {
<span class="nc bnc" id="L623" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L624">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L625" title="All 6 branches missed.">            if (line.equals(&quot;public int hashCode() {&quot;) || (line.startsWith(&quot;public boolean equals(&quot;) &amp;&amp; line.endsWith(&quot;) {&quot;))) {</span>
<span class="nc" id="L626">                return true;</span>
            }
        }
<span class="nc bnc" id="L629" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L630">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L631" title="All 6 branches missed.">            if (line.equals(&quot;public int hashCode() {&quot;) || (line.startsWith(&quot;public boolean equals(&quot;) &amp;&amp; line.endsWith(&quot;) {&quot;))) {</span>
<span class="nc" id="L632">                return true;</span>
            }
        }
<span class="nc" id="L635">        return false;</span>
    }

    private boolean parseManualToStringCode(int defLine) {
<span class="nc bnc" id="L639" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L640">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (line.equals(&quot;public String toString() {&quot;)) {</span>
<span class="nc" id="L642">                return true;</span>
            }
        }
<span class="nc bnc" id="L645" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L646">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">            if (line.equals(&quot;public String toString() {&quot;)) {</span>
<span class="nc" id="L648">                return true;</span>
            }
        }
<span class="nc" id="L651">        return false;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>