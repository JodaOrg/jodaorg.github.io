<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BeanParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda-Beans</a> &gt; <a href="index.source.html" class="el_package">org.joda.beans.gen</a> &gt; <span class="el_source">BeanParser.java</span></div><h1>BeanParser.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-present Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.beans.gen;

import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_BY_ARGS;
import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_BY_BUILDER;
import static org.joda.beans.gen.BeanGen.CONSTRUCTOR_NONE;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Parse bean information from source file.
 */
class BeanParser {

    /** Start marker. */
    private static final String AUTOGENERATED_START_TEXT = &quot;AUTOGENERATED START&quot;;
    /** Start marker. */
    private static final String AUTOGENERATED_START = &quot;\t//------------------------- AUTOGENERATED START -------------------------&quot;;
    /** End marker. */
    private static final String AUTOGENERATED_END = &quot;\t//-------------------------- AUTOGENERATED END --------------------------&quot;;
    /** Pattern to find bean type. */
    // handle three comma separated generic parameters
    // handle generic parameter extends clause
    // handle extends clause with further level of generic parameters
    // handle extends clause union types without generic parameters
<span class="nc" id="L46">    private static final Pattern BEAN_TYPE = Pattern.compile(&quot;.*class +(&quot; +</span>
            &quot;([A-Z][A-Za-z0-9_]+)&quot; +
                &quot;(?:&lt;&quot; +
                    &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                    &quot;(?:[,] +&quot; +
                        &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                        &quot;(?:[,] +&quot; +
                            &quot;([A-Z])( +extends +[A-Za-z0-9_]+(?:[&lt;][A-Za-z0-9_, ?]+[&gt;])?(?:[ ]+[&amp;][ ]+[A-Za-z0-9]+)*)?&quot; +
                        &quot;)?&quot; +
                    &quot;)?&quot; +
                &quot;&gt;)?&quot; +
            &quot;).*&quot;);
    /** Pattern to find super type. */
<span class="nc" id="L59">    private static final Pattern SUPER_TYPE = Pattern.compile(&quot;.*extends +(&quot; +</span>
            &quot;([A-Z][A-Za-z0-9_]+)&quot; +
                &quot;(?:&lt;&quot; +
                    &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)&quot; +
                    &quot;(?:[,] +&quot; +
                        &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)?&quot; +
                        &quot;(?:[,] +&quot; +
                            &quot;([A-Z][A-Za-z0-9_&lt;&gt; ]*)?&quot; +
                        &quot;)?&quot; +
                    &quot;)?&quot; +
                &quot;&gt;)?&quot; +
            &quot;).*&quot;);
    /** Pattern to find root type. */
<span class="nc" id="L72">    private static final Pattern SUPER_IMPL_TYPE = Pattern.compile(&quot;.*implements.*[ ,]((Immutable)?Bean)([ ,{]|$).*&quot;);</span>
    /** Pattern to find serializable interface. */
<span class="nc" id="L74">    private static final Pattern SERIALIZABLE_TYPE = Pattern.compile(&quot;.*implements.*[ ,]Serializable([ ,{]|$).*&quot;);</span>
    /** The style pattern. */
<span class="nc" id="L76">    private static final Pattern STYLE_PATTERN = Pattern.compile(&quot;.*[ ,(]style[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The metaScope pattern. */
<span class="nc" id="L78">    private static final Pattern META_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]metaScope[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The metaImplements pattern. */
<span class="nc" id="L80">    private static final Pattern META_IMPLEMENTS_PATTERN = Pattern.compile(&quot;.*[ ,(]metaImplements[ ]*[=][ ]*[\&quot;]([a-zA-Z0-9_.&lt;&gt;]*)[\&quot;].*&quot;);</span>
    /** The builderScope pattern. */
<span class="nc" id="L82">    private static final Pattern BUILDER_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]builderScope[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The builderStyle pattern. */
<span class="nc" id="L84">    private static final Pattern BUILDER_NAME_PATTERN = Pattern.compile(&quot;.*[ ,(]builderName[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The constructorScope pattern. */
<span class="nc" id="L86">    private static final Pattern CONSTRUCTOR_SCOPE_PATTERN = Pattern.compile(&quot;.*[ ,(]constructorScope[ ]*[=][ ]*[\&quot;]([a-zA-Z@]*)[\&quot;].*&quot;);</span>
    /** The factoryName pattern. */
<span class="nc" id="L88">    private static final Pattern FACTORY_NAME_PATTERN = Pattern.compile(&quot;.*[ ,(]factoryName[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The hierarchy pattern. */
<span class="nc" id="L90">    private static final Pattern HIERARCHY_PATTERN = Pattern.compile(&quot;.*[ ,(]hierarchy[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>
    /** The cacheHashCode pattern. */
<span class="nc" id="L92">    private static final Pattern CACHE_HASH_CODE_PATTERN = Pattern.compile(&quot;.*[ ,(]cacheHashCode[ ]*[=][ ]*(true|false).*&quot;);</span>
    /** The cloneStyle pattern. */
<span class="nc" id="L94">    private static final Pattern CLONE_STYLE_PATTERN = Pattern.compile(&quot;.*[ ,(]cloneStyle[ ]*[=][ ]*[\&quot;]([a-zA-Z]*)[\&quot;].*&quot;);</span>

    /** The validator pattern. */
<span class="nc" id="L97">    private static final Pattern VALIDATOR_PATTERN = Pattern.compile(</span>
            &quot;.*private[ ]+void[ ]+&quot; +
            &quot;([a-zA-Z][a-zA-Z0-9]*)[(][ ]*[)].*&quot;);
    /** The defaults pattern. */
<span class="nc" id="L101">    private static final Pattern DEFAULTS_PATTERN = Pattern.compile(</span>
            &quot;.*private[ ]+static[ ]+void[ ]+&quot; +
            &quot;([a-zA-Z][a-zA-Z0-9]*)[(][ ]*Builder[ ]+[a-zA-Z][a-zA-Z0-9]*[ ]*[)].*&quot;);

    /** The content to process. */
    private final File file;
    /** The content to process. */
    private final List&lt;String&gt; content;
    /** The content to process. */
    private final BeanGenConfig config;
    /** The content to process. */
    private int beanDefIndex;
    /** The start position of auto-generation. */
    private int autoStartIndex;
    /** The end position of auto-generation. */
    private int autoEndIndex;
    /** The list of property generators. */
    private List&lt;PropertyGen&gt; properties;

    /**
     * Constructor.
     * @param file  the file to process, not null
     * @param content  the content to process, not null
     */
<span class="nc" id="L125">    BeanParser(File file, List&lt;String&gt; content, BeanGenConfig config) {</span>
<span class="nc" id="L126">        this.file = file;</span>
<span class="nc" id="L127">        this.content = content;</span>
<span class="nc" id="L128">        this.config = config;</span>
<span class="nc" id="L129">    }</span>

    //-----------------------------------------------------------------------
    File getFile() {
<span class="nc" id="L133">        return file;</span>
    }

    String getFieldPrefix() {
<span class="nc" id="L137">        return config.getPrefix();</span>
    }

    BeanGenConfig getConfig() {
<span class="nc" id="L141">        return config;</span>
    }

    //-----------------------------------------------------------------------
    BeanGen parse() {
<span class="nc" id="L146">        BeanData data = new BeanData();</span>
<span class="nc" id="L147">        beanDefIndex = parseBeanDefinition();</span>
<span class="nc" id="L148">        data.getCurrentImports().addAll(parseImports(beanDefIndex));</span>
<span class="nc" id="L149">        data.setImportInsertLocation(parseImportLocation(beanDefIndex));</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (beanDefIndex &lt; 0) {</span>
<span class="nc" id="L151">            return new BeanGen(file, content, config, data);</span>
        }
<span class="nc" id="L153">        data.setBeanStyle(parseBeanStyle(beanDefIndex));</span>
<span class="nc" id="L154">        data.resolveBeanStyle(config.getDefaultStyle());</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (data.isBeanStyleValid() == false) {</span>
<span class="nc" id="L156">            throw new BeanCodeGenException(&quot;Invalid bean style: &quot; + data.getBeanStyle(), file, beanDefIndex);</span>
        }
<span class="nc" id="L158">        data.setConstructorScope(parseConstrucorScope(beanDefIndex));</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (data.isConstructorScopeValid() == false) {</span>
<span class="nc" id="L160">            throw new BeanCodeGenException(&quot;Invalid constructor scope: &quot; + data.getConstructorScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L162">        data.setBeanMetaScope(parseBeanMetaScope(beanDefIndex));</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (data.isBeanMetaScopeValid() == false) {</span>
<span class="nc" id="L164">            throw new BeanCodeGenException(&quot;Invalid meta-bean scope: &quot; + data.getBeanMetaScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L166">        data.setBeanMetaImplements(parseBeanMetaImplements(beanDefIndex));</span>
<span class="nc" id="L167">        data.setBeanBuilderScope(parseBeanBuilderScope(beanDefIndex));</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (data.isBeanBuilderScopeValid() == false) {</span>
<span class="nc" id="L169">            throw new BeanCodeGenException(&quot;Invalid bean builder scope: &quot; + data.getBeanBuilderScope(), file, beanDefIndex);</span>
        }
<span class="nc" id="L171">        data.setBeanBuilderName(parseBeanBuilderName(beanDefIndex));</span>
<span class="nc" id="L172">        data.setFactoryName(parseFactoryName(beanDefIndex));</span>
<span class="nc" id="L173">        data.setCacheHashCode(parseCacheHashCode(beanDefIndex));</span>
<span class="nc" id="L174">        data.setCloneStyle(parseCloneStyle(beanDefIndex));</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (data.isCloneStyleValid() == false) {</span>
<span class="nc" id="L176">            throw new BeanCodeGenException(&quot;Invalid clone style: &quot; + data.getCloneStyle(), file, beanDefIndex);</span>
        }
<span class="nc" id="L178">        data.setImmutableConstructor(parseImmutableConstructor(beanDefIndex));</span>
<span class="nc" id="L179">        data.setConstructable(parseConstructable(beanDefIndex));</span>
<span class="nc" id="L180">        data.setTypeParts(parseBeanType(beanDefIndex));</span>
<span class="nc" id="L181">        String classHeaderAfterType = classHeaderAfterType(beanDefIndex, data.getType());</span>
<span class="nc" id="L182">        data.setSuperTypeParts(parseBeanSuperType(classHeaderAfterType));</span>
<span class="nc" id="L183">        data.setSerializable(parseSerializable(classHeaderAfterType));</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (parseBeanHierarchy(beanDefIndex).equals(&quot;immutable&quot;)) {</span>
<span class="nc" id="L185">            data.setImmutable(true);</span>
<span class="nc" id="L186">            data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        } else if (data.getImmutableConstructor() == CONSTRUCTOR_NONE) {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (data.isImmutable()) {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                if (data.isTypeFinal()) {</span>
<span class="nc" id="L190">                    data.setConstructorStyle(CONSTRUCTOR_BY_ARGS);</span>
                } else {
<span class="nc" id="L192">                    data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
                }
            } else {
<span class="nc bnc" id="L195" title="All 2 branches missed.">                if (data.isBeanStyleLight()) {</span>
<span class="nc" id="L196">                    data.setConstructorStyle(CONSTRUCTOR_BY_ARGS);</span>
                } else {
<span class="nc" id="L198">                    data.setConstructorStyle(CONSTRUCTOR_BY_BUILDER);</span>
                }
            }
        } else {
<span class="nc" id="L202">            data.setConstructorStyle(data.getImmutableConstructor());</span>
        }
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (data.isImmutable()) {</span>
<span class="nc" id="L205">            data.setImmutableValidator(parseImmutableValidator(beanDefIndex));</span>
<span class="nc" id="L206">            data.setImmutableDefaults(parseImmutableDefaults(beanDefIndex));</span>
<span class="nc" id="L207">            data.setImmutablePreBuild(parseImmutablePreBuild(beanDefIndex));</span>
<span class="nc bnc" id="L208" title="All 4 branches missed.">            if (data.isBeanStyleLight() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L209">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Light beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L212" title="All 4 branches missed.">            if (data.isBeanStyleMinimal() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L213">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Minimal beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L216" title="All 4 branches missed.">            if (data.isFactoryRequired() &amp;&amp; !data.isRootClass()) {</span>
<span class="nc" id="L217">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean has no bean superclass&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L220" title="All 4 branches missed.">            if (data.isFactoryRequired() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L221">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean is final&quot;, file, beanDefIndex);
            }
        } else {
<span class="nc bnc" id="L225" title="All 4 branches missed.">            if (data.isBeanStyleLight() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L226">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Light beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L229" title="All 4 branches missed.">            if (data.isBeanStyleMinimal() &amp;&amp; !data.isTypeFinal()) {</span>
<span class="nc" id="L230">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Minimal beans must be declared final&quot;, file, beanDefIndex);
            }
<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (data.isFactoryRequired()) {</span>
<span class="nc" id="L234">                throw new BeanCodeGenException(</span>
                        &quot;Invalid bean style: Factory method only allowed when bean is immutable&quot;, file, beanDefIndex);
            }
        }
<span class="nc" id="L238">        properties = parseProperties(data);</span>
<span class="nc" id="L239">        autoStartIndex = parseStartAutogen();</span>
<span class="nc" id="L240">        autoEndIndex = parseEndAutogen();</span>
<span class="nc" id="L241">        data.setManualSerializationId(parseManualSerializationId(beanDefIndex));</span>
<span class="nc" id="L242">        data.setManualClone(parseManualClone(beanDefIndex));</span>
<span class="nc" id="L243">        data.setManualEqualsHashCode(parseManualEqualsHashCode(beanDefIndex));</span>
<span class="nc" id="L244">        data.setManualToStringCode(parseManualToStringCode(beanDefIndex));</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (data.isImmutable()) {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            for (PropertyGen prop : properties) {</span>
<span class="nc bnc" id="L247" title="All 4 branches missed.">                if (prop.getData().isDerived() == false &amp;&amp; prop.getData().isFinal() == false) {</span>
<span class="nc" id="L248">                    throw new BeanCodeGenException(&quot;ImmutableBean must have final properties: &quot; +</span>
<span class="nc" id="L249">                            data.getTypeRaw() + &quot;.&quot; + prop.getData().getFieldName(),</span>
<span class="nc" id="L250">                            file, prop.getData().getLineIndex());</span>
                }
<span class="nc" id="L252">            }</span>
        } else {
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (data.getImmutableConstructor() &gt; CONSTRUCTOR_NONE) {</span>
<span class="nc" id="L255">                throw new BeanCodeGenException(&quot;Mutable beans must not specify @ImmutableConstructor: &quot; +</span>
<span class="nc" id="L256">                        data.getTypeRaw(), file, beanDefIndex);</span>
            }
<span class="nc bnc" id="L258" title="All 4 branches missed.">            if (!&quot;smart&quot;.equals(data.getConstructorScope()) &amp;&amp; !data.isBeanStyleLight()) {</span>
<span class="nc" id="L259">                throw new BeanCodeGenException(&quot;Mutable beans must not specify @BeanDefinition(constructorScope): &quot; +</span>
<span class="nc" id="L260">                                data.getTypeRaw(), file, beanDefIndex);</span>
            }
        }
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (data.isCacheHashCode()) {</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">            data.setCacheHashCode(data.isImmutable() &amp;&amp; data.isManualEqualsHashCode() == false);</span>
        }
<span class="nc" id="L266">        return new BeanGen(file, content, config, data, properties, autoStartIndex, autoEndIndex);</span>
    }

    private String classHeaderAfterType(int defLine, String fullType) {
<span class="nc" id="L270">        StringBuilder buf = new StringBuilder(128);</span>
<span class="nc" id="L271">        boolean matchedType = false;</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc" id="L273">            String line = content.get(index);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (matchedType == false) {</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">                if (line.contains(fullType) == false) {</span>
<span class="nc" id="L276">                    continue;</span>
                }
<span class="nc" id="L278">                matchedType = true;</span>
<span class="nc" id="L279">                line = line.substring(line.indexOf(fullType) + fullType.length());</span>
            }
<span class="nc" id="L281">            buf.append(line).append(' ');</span>
<span class="nc bnc" id="L282" title="All 4 branches missed.">            if (line.trim().endsWith(&quot;{&quot;) &amp;&amp; !line.trim().startsWith(&quot;@&quot;)) {</span>
<span class="nc" id="L283">                break;</span>
            }
        }
<span class="nc" id="L286">        return buf.toString().trim();</span>
    }

    //-----------------------------------------------------------------------
    private int parseBeanDefinition() {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L292">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (line.startsWith(&quot;@BeanDefinition&quot;)) {</span>
<span class="nc" id="L294">                return index;</span>
            }
        }
<span class="nc" id="L297">        return -1;</span>
    }

    private Set&lt;String&gt; parseImports(int defLine) {
<span class="nc bnc" id="L301" title="All 2 branches missed.">        int end = defLine &lt; 0 ? content.size() : defLine;</span>
<span class="nc" id="L302">        Set&lt;String&gt; imports = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        for (int index = 0; index &lt; end; index++) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">            if (content.get(index).startsWith(&quot;import &quot;)) {</span>
<span class="nc" id="L305">                String imp = content.get(index).substring(7).trim();</span>
<span class="nc" id="L306">                imp = imp.substring(0, imp.indexOf(';'));</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">                if (imp.endsWith(&quot;.*&quot;) == false) {</span>
<span class="nc" id="L308">                    imports.add(imp);</span>
                }
            }
        }
<span class="nc" id="L312">        return imports;</span>
    }

    private int parseImportLocation(int defLine) {
<span class="nc bnc" id="L316" title="All 2 branches missed.">        int end = defLine &lt; 0 ? content.size() : defLine;</span>
<span class="nc" id="L317">        int location = 0;</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        for (int index = 0; index &lt; end; index++) {</span>
<span class="nc bnc" id="L319" title="All 4 branches missed.">            if (content.get(index).startsWith(&quot;import &quot;) || content.get(index).startsWith(&quot;package &quot;)) {</span>
<span class="nc" id="L320">                location = index;</span>
            }
        }
<span class="nc" id="L323">        return location;</span>
    }

    private String parseBeanStyle(int defLine) {
<span class="nc" id="L327">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L328">        Matcher matcher = STYLE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L330">            return matcher.group(1);</span>
        }
<span class="nc" id="L332">        return &quot;smart&quot;;</span>
    }

    private String parseConstrucorScope(int defLine) {
<span class="nc" id="L336">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L337">        Matcher matcher = CONSTRUCTOR_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L339">            return matcher.group(1);</span>
        }
<span class="nc" id="L341">        return &quot;smart&quot;;</span>
    }

    private String parseBeanMetaScope(int defLine) {
<span class="nc" id="L345">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L346">        Matcher matcher = META_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L348">            return matcher.group(1);</span>
        }
<span class="nc" id="L350">        return &quot;smart&quot;;</span>
    }

    private String parseBeanMetaImplements(int defLine) {
<span class="nc" id="L354">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L355">        Matcher matcher = META_IMPLEMENTS_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L357">            return matcher.group(1);</span>
        }
<span class="nc" id="L359">        return &quot;&quot;;</span>
    }

    private String parseBeanBuilderScope(int defLine) {
<span class="nc" id="L363">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L364">        Matcher matcher = BUILDER_SCOPE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L366">            return matcher.group(1);</span>
        }
<span class="nc" id="L368">        return &quot;smart&quot;;</span>
    }

    private String parseBeanBuilderName(int defLine) {
<span class="nc" id="L372">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L373">        Matcher matcher = BUILDER_NAME_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L375">            return matcher.group(1);</span>
        }
<span class="nc" id="L377">        return &quot;&quot;;</span>
    }

    private String parseFactoryName(int defLine) {
<span class="nc" id="L381">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L382">        Matcher matcher = FACTORY_NAME_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L384">            return matcher.group(1);</span>
        }
<span class="nc" id="L386">        return &quot;&quot;;</span>
    }

    private String parseBeanHierarchy(int defLine) {
<span class="nc" id="L390">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L391">        Matcher matcher = HIERARCHY_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L393">            return matcher.group(1);</span>
        }
<span class="nc" id="L395">        return &quot;&quot;;</span>
    }

    private boolean parseCacheHashCode(int defLine) {
<span class="nc" id="L399">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L400">        Matcher matcher = CACHE_HASH_CODE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L402">            return Boolean.valueOf(matcher.group(1));</span>
        }
<span class="nc" id="L404">        return false;</span>
    }

    private String parseCloneStyle(int defLine) {
<span class="nc" id="L408">        String line = content.get(defLine).trim();</span>
<span class="nc" id="L409">        Matcher matcher = CLONE_STYLE_PATTERN.matcher(line);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (matcher.matches()) {</span>
<span class="nc" id="L411">            return matcher.group(1);</span>
        }
<span class="nc" id="L413">        return &quot;smart&quot;;</span>
    }

    private boolean parseConstructable(int defLine) {
<span class="nc bnc" id="L417" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">            if (content.get(index).contains(&quot; abstract class &quot;)) {</span>
<span class="nc" id="L419">                return false;</span>
            }
        }
<span class="nc" id="L422">        return true;</span>
    }

    private String[] parseBeanType(int defLine) {
<span class="nc" id="L426">        Matcher matcher = BEAN_TYPE.matcher(&quot;&quot;);</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc" id="L428">            String line = content.get(index);</span>
<span class="nc" id="L429">            matcher.reset(line);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">            if (matcher.matches()) {</span>
<span class="nc" id="L431">                String startStr = line.substring(0, matcher.start(1));</span>
<span class="nc bnc" id="L432" title="All 4 branches missed.">                String fnl = startStr.contains(&quot; final &quot;) || startStr.startsWith(&quot;final &quot;) ? &quot;final&quot; : null;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">                String scope = startStr.contains(&quot;public &quot;) ? &quot;public&quot; : &quot;package&quot;;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                scope = startStr.contains(&quot;protected &quot;) ? &quot;protected&quot; : scope;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                scope = startStr.contains(&quot;private &quot;) ? &quot;private&quot; : scope;</span>
<span class="nc" id="L436">                return new String[] {fnl, scope, matcher.group(1), matcher.group(2), matcher.group(3),</span>
<span class="nc" id="L437">                        matcher.group(4), matcher.group(5), matcher.group(6), matcher.group(7), matcher.group(8)};</span>
            }
<span class="nc bnc" id="L439" title="All 2 branches missed.">            if (line.contains(AUTOGENERATED_START_TEXT)) {</span>
<span class="nc" id="L440">                break;</span>
            }
        }
<span class="nc" id="L443">        throw new BeanCodeGenException(&quot;Unable to locate bean class name&quot;, file, beanDefIndex);</span>
    }

    private String[] parseBeanSuperType(String classHeaderAfterType) {
        // this uses classHeaderAfterType as extends has two meanings in class headers
        // search for implements
<span class="nc" id="L449">        Matcher matcherImplements = SUPER_IMPL_TYPE.matcher(classHeaderAfterType);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (matcherImplements.matches()) {</span>
<span class="nc" id="L451">            return new String[] {matcherImplements.group(1)};</span>
        }
        // search for extends
<span class="nc" id="L454">        Matcher matcherExtends = SUPER_TYPE.matcher(classHeaderAfterType);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (matcherExtends.matches()) {</span>
<span class="nc" id="L456">            return new String[] {matcherExtends.group(1), matcherExtends.group(2), matcherExtends.group(3),</span>
<span class="nc" id="L457">                    matcherExtends.group(4), matcherExtends.group(5)};</span>
        }
<span class="nc" id="L459">        throw new BeanCodeGenException(&quot;Unable to locate bean superclass&quot;, file, beanDefIndex);</span>
    }

    private boolean parseSerializable(String classHeaderAfterType) {
<span class="nc" id="L463">        return SERIALIZABLE_TYPE.matcher(classHeaderAfterType).matches();</span>
    }

    private boolean parseManualSerializationId(int defLine) {
<span class="nc bnc" id="L467" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">            if (content.get(index).trim().startsWith(&quot;private static final long serialVersionUID&quot;)) {</span>
<span class="nc" id="L469">                return true;</span>
            }
        }
<span class="nc" id="L472">        return false;</span>
    }

    private int parseImmutableConstructor(int defLine) {
<span class="nc" id="L476">        int found = CONSTRUCTOR_NONE;</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableConstructor&quot;)) {</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">                if (found &gt; 0) {</span>
<span class="nc" id="L480">                    throw new BeanCodeGenException(&quot;Only one @ImmutableConstructor may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L482">                found = CONSTRUCTOR_BY_ARGS;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L484">                    String nextLine = content.get(index + 1);</span>
<span class="nc bnc" id="L485" title="All 4 branches missed.">                    if (nextLine.contains(&quot;Builder &quot;) || nextLine.contains(&quot;Builder&lt;&quot;)) {</span>
<span class="nc" id="L486">                        found = CONSTRUCTOR_BY_BUILDER;</span>
                    }
                }
            }
        }
<span class="nc" id="L491">        return found;</span>
    }

    private String parseImmutableValidator(int defLine) {
<span class="nc" id="L495">        boolean found = false;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableValidator&quot;)) {</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L499">                    throw new BeanCodeGenException(&quot;Only one @ImmutableValidator may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L501">                found = true;</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L503">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L504">                    Matcher matcher = VALIDATOR_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L506">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L508">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutableValidator method must be private void and no-args&quot;, file, index + 1);
                }
            }
        }
<span class="nc" id="L513">        return null;</span>
    }

    private String parseImmutableDefaults(int defLine) {
<span class="nc" id="L517">        boolean found = false;</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutableDefaults&quot;)) {</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L521">                    throw new BeanCodeGenException(&quot;Only one @ImmutableDefaults may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L523">                found = true;</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L525">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L526">                    Matcher matcher = DEFAULTS_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L528">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L530">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutableDefaults method must be private static void and have one argument of type 'Builder'&quot;,
                        file, index + 1);
                }
            }
        }
<span class="nc" id="L536">        return null;</span>
    }

    private String parseImmutablePreBuild(int defLine) {
<span class="nc" id="L540">        boolean found = false;</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        for (int index = defLine; index &lt; content.size(); index++) {</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            if (content.get(index).trim().equals(&quot;@ImmutablePreBuild&quot;)) {</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">                if (found) {</span>
<span class="nc" id="L544">                    throw new BeanCodeGenException(&quot;Only one @ImmutablePreBuild may be specified&quot;, file, index);</span>
                }
<span class="nc" id="L546">                found = true;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">                if (index + 1 &lt; content.size()) {</span>
<span class="nc" id="L548">                    String nextLine = content.get(index + 1);</span>
<span class="nc" id="L549">                    Matcher matcher = DEFAULTS_PATTERN.matcher(nextLine);</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">                    if (matcher.matches()) {</span>
<span class="nc" id="L551">                        return matcher.group(1);</span>
                    }
<span class="nc" id="L553">                    throw new BeanCodeGenException(</span>
                        &quot;@ImmutablePreBuild method must be private static void and have one argument of type 'Builder'&quot;,
                        file, index + 1);
                }
            }
        }
<span class="nc" id="L559">        return null;</span>
    }

    private List&lt;PropertyGen&gt; parseProperties(BeanData data) {
<span class="nc" id="L563">        List&lt;PropertyGen&gt; props = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L565">            String line = content.get(index).trim();</span>
<span class="nc" id="L566">            PropertyParser parser = new PropertyParser(this);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">            if (line.startsWith(&quot;@PropertyDefinition&quot;)) {</span>
<span class="nc" id="L568">                PropertyGen prop = parser.parse(data, content, index);</span>
<span class="nc" id="L569">                props.add(prop);</span>
<span class="nc" id="L570">                data.getProperties().add(prop.getData());</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">            } else if (line.startsWith(&quot;@DerivedProperty&quot;)) {</span>
<span class="nc" id="L572">                PropertyGen prop = parser.parseDerived(data, content, index);</span>
<span class="nc" id="L573">                props.add(prop);</span>
<span class="nc" id="L574">                data.getProperties().add(prop.getData());</span>
            }
        }
<span class="nc" id="L577">        return props;</span>
    }

    private int parseStartAutogen() {
<span class="nc bnc" id="L581" title="All 2 branches missed.">        for (int index = 0; index &lt; content.size(); index++) {</span>
<span class="nc" id="L582">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (line.contains(&quot; AUTOGENERATED START &quot;)) {</span>
<span class="nc" id="L584">                content.set(index, AUTOGENERATED_START);</span>
<span class="nc" id="L585">                return index;</span>
            }
        }
<span class="nc bnc" id="L588" title="All 2 branches missed.">        for (int index = content.size() - 1; index &gt;= 0; index--) {</span>
<span class="nc" id="L589">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">            if (line.equals(&quot;}&quot;)) {</span>
<span class="nc" id="L591">                content.add(index, AUTOGENERATED_START);</span>
<span class="nc" id="L592">                return index;</span>
            }
<span class="nc bnc" id="L594" title="All 2 branches missed.">            if (line.length() &gt; 0) {</span>
<span class="nc" id="L595">                break;</span>
            }
        }
<span class="nc" id="L598">        throw new BeanCodeGenException(&quot;Unable to locate start autogeneration point&quot;, file, beanDefIndex);</span>
    }

    private int parseEndAutogen() {
<span class="nc bnc" id="L602" title="All 2 branches missed.">        for (int index = autoStartIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L603">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">            if (line.contains(&quot; AUTOGENERATED END &quot;)) {</span>
<span class="nc" id="L605">                content.set(index, AUTOGENERATED_END);</span>
<span class="nc" id="L606">                return index;</span>
            }
        }
<span class="nc" id="L609">        content.add(autoStartIndex + 1, AUTOGENERATED_END);</span>
<span class="nc" id="L610">        return autoStartIndex + 1;</span>
    }

    private boolean parseManualClone(int defLine) {
<span class="nc bnc" id="L614" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L615">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L616" title="All 4 branches missed.">            if (line.startsWith(&quot;public &quot;) &amp;&amp; line.endsWith(&quot; clone() {&quot;)) {</span>
<span class="nc" id="L617">                return true;</span>
            }
        }
<span class="nc bnc" id="L620" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L621">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L622" title="All 4 branches missed.">            if (line.startsWith(&quot;public &quot;) &amp;&amp; line.endsWith(&quot; clone() {&quot;)) {</span>
<span class="nc" id="L623">                return true;</span>
            }
        }
<span class="nc" id="L626">        return false;</span>
    }

    private boolean parseManualEqualsHashCode(int defLine) {
<span class="nc bnc" id="L630" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L631">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L632" title="All 6 branches missed.">            if (line.equals(&quot;public int hashCode() {&quot;) || (line.startsWith(&quot;public boolean equals(&quot;) &amp;&amp; line.endsWith(&quot;) {&quot;))) {</span>
<span class="nc" id="L633">                return true;</span>
            }
        }
<span class="nc bnc" id="L636" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L637">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L638" title="All 6 branches missed.">            if (line.equals(&quot;public int hashCode() {&quot;) || (line.startsWith(&quot;public boolean equals(&quot;) &amp;&amp; line.endsWith(&quot;) {&quot;))) {</span>
<span class="nc" id="L639">                return true;</span>
            }
        }
<span class="nc" id="L642">        return false;</span>
    }

    private boolean parseManualToStringCode(int defLine) {
<span class="nc bnc" id="L646" title="All 2 branches missed.">        for (int index = defLine; index &lt; autoStartIndex; index++) {</span>
<span class="nc" id="L647">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">            if (line.equals(&quot;public String toString() {&quot;)) {</span>
<span class="nc" id="L649">                return true;</span>
            }
        }
<span class="nc bnc" id="L652" title="All 2 branches missed.">        for (int index = autoEndIndex; index &lt; content.size(); index++) {</span>
<span class="nc" id="L653">            String line = content.get(index).trim();</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">            if (line.equals(&quot;public String toString() {&quot;)) {</span>
<span class="nc" id="L655">                return true;</span>
            }
        }
<span class="nc" id="L658">        return false;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>